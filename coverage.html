
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gorogue-cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yuru-sha/gorogue/cmd/gorogue-cli/main.go (0.0%)</option>
				
				<option value="file1">github.com/yuru-sha/gorogue/cmd/gorogue/main.go (0.0%)</option>
				
				<option value="file2">github.com/yuru-sha/gorogue/internal/core/cli/commands.go (26.4%)</option>
				
				<option value="file3">github.com/yuru-sha/gorogue/internal/core/cli/game_commands.go (1.3%)</option>
				
				<option value="file4">github.com/yuru-sha/gorogue/internal/core/engine.go (0.0%)</option>
				
				<option value="file5">github.com/yuru-sha/gorogue/internal/core/entity/entity.go (0.0%)</option>
				
				<option value="file6">github.com/yuru-sha/gorogue/internal/core/entity/position.go (0.0%)</option>
				
				<option value="file7">github.com/yuru-sha/gorogue/internal/core/state/state.go (0.0%)</option>
				
				<option value="file8">github.com/yuru-sha/gorogue/internal/core/wizard/wizard.go (0.0%)</option>
				
				<option value="file9">github.com/yuru-sha/gorogue/internal/game/actor/actor.go (100.0%)</option>
				
				<option value="file10">github.com/yuru-sha/gorogue/internal/game/actor/monster.go (0.0%)</option>
				
				<option value="file11">github.com/yuru-sha/gorogue/internal/game/actor/player.go (0.0%)</option>
				
				<option value="file12">github.com/yuru-sha/gorogue/internal/game/dungeon/dungeon_manager.go (0.0%)</option>
				
				<option value="file13">github.com/yuru-sha/gorogue/internal/game/dungeon/level.go (0.0%)</option>
				
				<option value="file14">github.com/yuru-sha/gorogue/internal/game/dungeon/tile.go (0.0%)</option>
				
				<option value="file15">github.com/yuru-sha/gorogue/internal/game/identification/identification.go (0.0%)</option>
				
				<option value="file16">github.com/yuru-sha/gorogue/internal/game/inventory/inventory.go (62.8%)</option>
				
				<option value="file17">github.com/yuru-sha/gorogue/internal/game/item/item.go (0.0%)</option>
				
				<option value="file18">github.com/yuru-sha/gorogue/internal/game/magic/effects.go (0.0%)</option>
				
				<option value="file19">github.com/yuru-sha/gorogue/internal/ui/screen/game_screen_core.go (0.0%)</option>
				
				<option value="file20">github.com/yuru-sha/gorogue/internal/ui/screen/game_screen_gameplay.go (0.0%)</option>
				
				<option value="file21">github.com/yuru-sha/gorogue/internal/ui/screen/game_screen_input.go (0.0%)</option>
				
				<option value="file22">github.com/yuru-sha/gorogue/internal/ui/screen/game_screen_inventory.go (0.0%)</option>
				
				<option value="file23">github.com/yuru-sha/gorogue/internal/ui/screen/game_screen_render.go (0.0%)</option>
				
				<option value="file24">github.com/yuru-sha/gorogue/internal/ui/screen/menu_screen.go (0.0%)</option>
				
				<option value="file25">github.com/yuru-sha/gorogue/internal/utils/logger/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// GoRogue CLI - Terminal-based CLI mode like PyRogue
package main

import (
        "bufio"
        "flag"
        "fmt"
        "os"
        "strings"

        "github.com/yuru-sha/gorogue/internal/core"
        "github.com/yuru-sha/gorogue/internal/core/cli"
        "github.com/yuru-sha/gorogue/internal/game/actor"
        "github.com/yuru-sha/gorogue/internal/game/dungeon"
        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

var (
        debugMode   = flag.Bool("debug", false, "Enable debug mode")
        helpFlag    = flag.Bool("help", false, "Show help information")
        interactive = flag.Bool("interactive", true, "Run in interactive mode")
)

func main() <span class="cov0" title="0">{
        flag.Parse()

        if *helpFlag </span><span class="cov0" title="0">{
                showHelp()
                return
        }</span>

        // Initialize logger
        <span class="cov0" title="0">if err := logger.Setup(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer logger.Cleanup()

        if *debugMode </span><span class="cov0" title="0">{
                logger.Info("Starting GoRogue CLI in debug mode")
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Starting GoRogue CLI")
        }</span>

        // Initialize game engine
        <span class="cov0" title="0">engine := core.NewEngine()
        if engine == nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to initialize game engine")
                os.Exit(1)
        }</span>

        // Initialize game world for CLI commands
        <span class="cov0" title="0">player := actor.NewPlayer(1, 1)
        level := &amp;dungeon.Level{
                Width:    80,
                Height:   24,
                Tiles:    make([][]*dungeon.Tile, 80),
                Monsters: make([]*actor.Monster, 0),
                Items:    make([]*item.Item, 0),
                Rooms:    make([]*dungeon.Room, 0),
        }

        // Initialize CLI mode
        cliMode := cli.NewCLIMode(level, player)
        cliMode.IsActive = true

        if *interactive </span><span class="cov0" title="0">{
                runInteractiveMode(cliMode)
        }</span> else<span class="cov0" title="0"> {
                runBatchMode(cliMode)
        }</span>
}

func showHelp() <span class="cov0" title="0">{
        fmt.Println("GoRogue CLI - Terminal-based roguelike game")
        fmt.Println()
        fmt.Println("Usage:")
        fmt.Println("  gorogue-cli [options]")
        fmt.Println()
        fmt.Println("Options:")
        fmt.Println("  -debug         Enable debug mode")
        fmt.Println("  -help          Show this help")
        fmt.Println("  -interactive   Run in interactive mode (default: true)")
        fmt.Println()
        fmt.Println("Examples:")
        fmt.Println("  gorogue-cli                    # Start interactive CLI")
        fmt.Println("  gorogue-cli -debug             # Start with debug mode")
        fmt.Println("  echo 'status' | gorogue-cli -interactive=false  # Batch mode")
        fmt.Println()
        fmt.Println("Interactive Commands:")
        fmt.Println("  help           Show all available commands")
        fmt.Println("  status         Show player status")
        fmt.Println("  heal [amount]  Heal player")
        fmt.Println("  gold &lt;amount&gt;  Add gold")
        fmt.Println("  create &lt;type&gt;  Create item")
        fmt.Println("  teleport &lt;x&gt; &lt;y&gt;  Teleport player")
        fmt.Println("  quit, exit     Exit CLI")
        fmt.Println()
        fmt.Println("For full command list, run 'help' in interactive mode.")
}</span>

func runInteractiveMode(cliMode *cli.CLIMode) <span class="cov0" title="0">{
        fmt.Println("╔══════════════════════════════════════════════════════════════════════════════╗")
        fmt.Println("║                            GoRogue CLI Mode                                 ║")
        fmt.Println("║                      PyRogue-compatible CLI Interface                       ║")
        fmt.Println("╚══════════════════════════════════════════════════════════════════════════════╝")
        fmt.Println()
        fmt.Println("Welcome to GoRogue CLI! Type 'help' for commands, 'quit' to exit.")
        fmt.Println()

        scanner := bufio.NewScanner(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Print("gorogue&gt; ")

                if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">input := strings.TrimSpace(scanner.Text())
                if input == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Handle special commands
                <span class="cov0" title="0">switch strings.ToLower(input) </span>{
                case "quit", "exit", "q":<span class="cov0" title="0">
                        fmt.Println("Goodbye!")
                        return</span>
                case "clear", "cls":<span class="cov0" title="0">
                        fmt.Print("\033[2J\033[1;1H") // Clear screen
                        continue</span>
                }

                // Execute CLI command
                <span class="cov0" title="0">result := cliMode.ExecuteCommand(input)
                fmt.Println(result)
                fmt.Println()</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading input: %v\n", err)
        }</span>
}

func runBatchMode(cliMode *cli.CLIMode) <span class="cov0" title="0">{
        fmt.Println("GoRogue CLI - Batch Mode")
        fmt.Println("Reading commands from stdin...")
        fmt.Println()

        scanner := bufio.NewScanner(os.Stdin)
        commandCount := 0

        for scanner.Scan() </span><span class="cov0" title="0">{
                input := strings.TrimSpace(scanner.Text())
                if input == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">commandCount++
                fmt.Printf("[%d] Executing: %s\n", commandCount, input)

                result := cliMode.ExecuteCommand(input)
                fmt.Println(result)
                fmt.Println("---")</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading input: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Batch mode completed. Executed %d commands.\n", commandCount)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// GoRogue - SDL2 ASCII文字表示版メイン

package main

import (
        "context"
        "image"
        "image/color"
        "image/draw"
        "os"

        "github.com/anaseto/gruid"
        "github.com/anaseto/gruid-sdl"
        "github.com/yuru-sha/gorogue/internal/core"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
        "golang.org/x/image/font"
        "golang.org/x/image/font/basicfont"
        "golang.org/x/image/math/fixed"
)

// ASCIITileManager implements a simple ASCII font-based tile manager
type ASCIITileManager struct {
        cellWidth  int
        cellHeight int
}

// NewASCIITileManager creates a new ASCII tile manager
func NewASCIITileManager(cellWidth, cellHeight int) *ASCIITileManager <span class="cov0" title="0">{
        return &amp;ASCIITileManager{
                cellWidth:  cellWidth,
                cellHeight: cellHeight,
        }
}</span>

// TileSize returns the size of tiles
func (tm *ASCIITileManager) TileSize() gruid.Point <span class="cov0" title="0">{
        return gruid.Point{X: tm.cellWidth, Y: tm.cellHeight}
}</span>

// GetImage returns an image for a given cell
func (tm *ASCIITileManager) GetImage(cell gruid.Cell) image.Image <span class="cov0" title="0">{
        // Create a new image for the cell
        img := image.NewRGBA(image.Rect(0, 0, tm.cellWidth, tm.cellHeight))

        // Background color
        bgColor := color.RGBA{0, 0, 0, 255} // Black background
        if cell.Style.Bg != 0 </span><span class="cov0" title="0">{
                bgColor = tm.gruidColorToRGBA(cell.Style.Bg)
        }</span>

        // Fill background
        <span class="cov0" title="0">draw.Draw(img, img.Bounds(), &amp;image.Uniform{bgColor}, image.Point{}, draw.Src)

        // Text color
        textColor := color.RGBA{255, 255, 255, 255} // White text
        if cell.Style.Fg != 0 </span><span class="cov0" title="0">{
                textColor = tm.gruidColorToRGBA(cell.Style.Fg)
        }</span>

        // Draw the character
        <span class="cov0" title="0">if cell.Rune != 0 &amp;&amp; cell.Rune != ' ' </span><span class="cov0" title="0">{
                tm.drawCharacter(img, cell.Rune, textColor)
        }</span>

        <span class="cov0" title="0">return img</span>
}

// gruidColorToRGBA converts gruid.Color to color.RGBA
func (tm *ASCIITileManager) gruidColorToRGBA(c gruid.Color) color.RGBA <span class="cov0" title="0">{
        r := uint8((c &gt;&gt; 16) &amp; 0xFF)
        g := uint8((c &gt;&gt; 8) &amp; 0xFF)
        b := uint8(c &amp; 0xFF)
        return color.RGBA{r, g, b, 255}
}</span>

// drawCharacter draws a character on the image
func (tm *ASCIITileManager) drawCharacter(img *image.RGBA, r rune, textColor color.RGBA) <span class="cov0" title="0">{
        // Use a font optimized for PyRogue-style display
        face := basicfont.Face7x13

        // Create a font drawer with PyRogue-style positioning
        drawer := &amp;font.Drawer{
                Dst:  img,
                Src:  &amp;image.Uniform{textColor},
                Face: face,
                Dot:  fixed.Point26_6{X: fixed.Int26_6(1 &lt;&lt; 6), Y: fixed.Int26_6(tm.cellHeight-2) &lt;&lt; 6},
        }

        // Draw the character
        drawer.DrawString(string(r))
}</span>

func main() <span class="cov0" title="0">{
        // ロガーの初期化
        if err := logger.Setup(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer logger.Cleanup()

        logger.Info("Starting GoRogue", "render_mode", "sdl2_ascii")

        // ゲームエンジンの初期化
        engine := core.NewEngine()
        if engine == nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize game engine")
                os.Exit(1)
        }</span>

        // SDL2ドライバーの設定 - ASCII文字表示用（PyRogue風）
        <span class="cov0" title="0">config := sdl.Config{
                TileManager: NewASCIITileManager(10, 14), // 10x14のPyRogue風サイズ
                Width:       80,
                Height:      50,
                WindowTitle: "GoRogue - ASCII Roguelike",
                Fullscreen:  false,
        }

        driver := sdl.NewDriver(config)

        // ドライバーの初期化
        if err := driver.Init(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize SDL driver", "error", err.Error())
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer driver.Close()

        // アプリケーションの作成と実行
        app := gruid.NewApp(gruid.AppConfig{
                Driver: driver,
                Model:  engine,
        })

        // アプリケーションの実行
        if err := app.Start(context.Background()); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Game terminated with error", "error", err.Error())
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cli

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/yuru-sha/gorogue/internal/game/actor"
        "github.com/yuru-sha/gorogue/internal/game/dungeon"
        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

const (
        equipmentWeapon = "weapon"
        equipmentArmor  = "armor"
        commandAll      = "all"
)

// CLIMode provides command-line interface for debugging and AI control
type CLIMode struct {
        IsActive bool
        Level    *dungeon.Level
        Player   *actor.Player
        Commands map[string]*Command
}

// Command represents a CLI command
type Command struct {
        Name        string
        Description string
        Usage       string
        Handler     func(args []string) string
}

// NewCLIMode creates a new CLI mode instance
func NewCLIMode(level *dungeon.Level, player *actor.Player) *CLIMode <span class="cov8" title="1">{
        cli := &amp;CLIMode{
                IsActive: false,
                Level:    level,
                Player:   player,
                Commands: make(map[string]*Command),
        }

        cli.registerCommands()
        cli.registerGameCommands()
        return cli
}</span>

// registerCommands registers all available commands
func (c *CLIMode) registerCommands() <span class="cov8" title="1">{
        commands := []*Command{
                {
                        Name:        "help",
                        Description: "Show all available commands",
                        Usage:       "help [command]",
                        Handler:     c.helpCommand,
                },
                {
                        Name:        "status",
                        Description: "Show player status",
                        Usage:       "status",
                        Handler:     c.statusCommand,
                },
                {
                        Name:        "heal",
                        Description: "Heal player",
                        Usage:       "heal [amount|full]",
                        Handler:     c.healCommand,
                },
                {
                        Name:        "gold",
                        Description: "Add gold to player",
                        Usage:       "gold &lt;amount&gt;",
                        Handler:     c.goldCommand,
                },
                {
                        Name:        "exp",
                        Description: "Add experience to player",
                        Usage:       "exp &lt;amount&gt;",
                        Handler:     c.expCommand,
                },
                {
                        Name:        "teleport",
                        Description: "Teleport player to coordinates",
                        Usage:       "teleport &lt;x&gt; &lt;y&gt;",
                        Handler:     c.teleportCommand,
                },
                {
                        Name:        "create",
                        Description: "Create item at position",
                        Usage:       "create &lt;item_type&gt; [x] [y]",
                        Handler:     c.createCommand,
                },
                {
                        Name:        "kill",
                        Description: "Kill monsters",
                        Usage:       "kill [all|&lt;x&gt; &lt;y&gt;]",
                        Handler:     c.killCommand,
                },
                {
                        Name:        "level",
                        Description: "Change dungeon level",
                        Usage:       "level &lt;floor&gt;",
                        Handler:     c.levelCommand,
                },
                {
                        Name:        "identify",
                        Description: "Identify all items",
                        Usage:       "identify [all|&lt;item_type&gt;]",
                        Handler:     c.identifyCommand,
                },
                {
                        Name:        "map",
                        Description: "Reveal map or get map info",
                        Usage:       "map [reveal|info]",
                        Handler:     c.mapCommand,
                },
                {
                        Name:        "inventory",
                        Description: "Show or modify inventory",
                        Usage:       "inventory [clear|add &lt;item&gt;]",
                        Handler:     c.inventoryCommand,
                },
                {
                        Name:        "save",
                        Description: "Save game state",
                        Usage:       "save [filename]",
                        Handler:     c.saveCommand,
                },
                {
                        Name:        "load",
                        Description: "Load game state",
                        Usage:       "load [filename]",
                        Handler:     c.loadCommand,
                },
                {
                        Name:        "set",
                        Description: "Set player attributes",
                        Usage:       "set &lt;attribute&gt; &lt;value&gt;",
                        Handler:     c.setCommand,
                },
                {
                        Name:        "spawn",
                        Description: "Spawn monsters",
                        Usage:       "spawn &lt;monster_type&gt; [x] [y] [count]",
                        Handler:     c.spawnCommand,
                },
                {
                        Name:        "debug",
                        Description: "Debug information",
                        Usage:       "debug [memory|performance|entities]",
                        Handler:     c.debugCommand,
                },
        }

        for _, cmd := range commands </span><span class="cov8" title="1">{
                c.Commands[cmd.Name] = cmd
        }</span>
}

// ExecuteCommand executes a CLI command
func (c *CLIMode) ExecuteCommand(input string) string <span class="cov8" title="1">{
        if !c.IsActive </span><span class="cov0" title="0">{
                return "CLI mode is not active"
        }</span>

        <span class="cov8" title="1">parts := strings.Fields(strings.TrimSpace(input))
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return "No command entered"
        }</span>

        <span class="cov8" title="1">commandName := strings.ToLower(parts[0])
        args := parts[1:]

        if cmd, exists := c.Commands[commandName]; exists </span><span class="cov8" title="1">{
                logger.Info("CLI command executed", "command", commandName, "args", args)
                return cmd.Handler(args)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("Unknown command: %s. Type 'help' for available commands.", commandName)</span>
}

// Toggle toggles CLI mode on/off
func (c *CLIMode) Toggle() <span class="cov8" title="1">{
        c.IsActive = !c.IsActive
        status := "OFF"
        if c.IsActive </span><span class="cov8" title="1">{
                status = "ON"
        }</span>
        <span class="cov8" title="1">logger.Info("CLI mode toggled", "status", status)</span>
}

// SetLevel updates the level reference
func (c *CLIMode) SetLevel(level *dungeon.Level) <span class="cov0" title="0">{
        c.Level = level
}</span>

// helpCommand shows help information
func (c *CLIMode) helpCommand(args []string) string <span class="cov8" title="1">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                // Show help for specific command
                if cmd, exists := c.Commands[args[0]]; exists </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s: %s\nUsage: %s", cmd.Name, cmd.Description, cmd.Usage)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Unknown command: %s", args[0])</span>
        }

        // Show all commands
        <span class="cov8" title="1">result := "Available commands:\n"
        for name, cmd := range c.Commands </span><span class="cov8" title="1">{
                result += fmt.Sprintf("  %-12s - %s\n", name, cmd.Description)
        }</span>
        <span class="cov8" title="1">result += "\nType 'help &lt;command&gt;' for detailed usage."
        return result</span>
}

// statusCommand shows player status
func (c *CLIMode) statusCommand(args []string) string <span class="cov8" title="1">{
        return fmt.Sprintf("Player Status:\n"+
                "Level: %d\n"+
                "HP: %d/%d\n"+
                "Attack: %d\n"+
                "Defense: %d\n"+
                "Experience: %d\n"+
                "Gold: %d\n"+
                "Hunger: %d\n"+
                "Position: (%d, %d)\n"+
                "Inventory: %d/%d items",
                c.Player.Level, c.Player.HP, c.Player.MaxHP,
                c.Player.Attack, c.Player.Defense, c.Player.Exp,
                c.Player.Gold, c.Player.Hunger,
                c.Player.Position.X, c.Player.Position.Y,
                c.Player.Inventory.Size(), c.Player.Inventory.Capacity)
}</span>

// healCommand heals the player
func (c *CLIMode) healCommand(args []string) string <span class="cov8" title="1">{
        if len(args) == 0 || args[0] == "full" </span><span class="cov8" title="1">{
                c.Player.HP = c.Player.MaxHP
                return "Player fully healed"
        }</span>

        <span class="cov8" title="1">amount, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return "Invalid heal amount"
        }</span>

        <span class="cov8" title="1">oldHP := c.Player.HP
        c.Player.Heal(amount)
        healed := c.Player.HP - oldHP
        return fmt.Sprintf("Healed %d HP (was %d, now %d)", healed, oldHP, c.Player.HP)</span>
}

// goldCommand adds gold to player
func (c *CLIMode) goldCommand(args []string) string <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return "Usage: gold &lt;amount&gt;"
        }</span>

        <span class="cov8" title="1">amount, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return "Invalid gold amount"
        }</span>

        <span class="cov8" title="1">c.Player.AddGold(amount)
        return fmt.Sprintf("Added %d gold (total: %d)", amount, c.Player.Gold)</span>
}

// expCommand adds experience to player
func (c *CLIMode) expCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: exp &lt;amount&gt;"
        }</span>

        <span class="cov0" title="0">amount, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return "Invalid experience amount"
        }</span>

        <span class="cov0" title="0">oldLevel := c.Player.Level
        c.Player.GainExp(amount)

        if c.Player.Level &gt; oldLevel </span><span class="cov0" title="0">{
                return fmt.Sprintf("Added %d exp, leveled up! (Level %d -&gt; %d)", amount, oldLevel, c.Player.Level)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Added %d exp (total: %d)", amount, c.Player.Exp)</span>
}

// teleportCommand teleports player
func (c *CLIMode) teleportCommand(args []string) string <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return "Usage: teleport &lt;x&gt; &lt;y&gt;"
        }</span>

        <span class="cov0" title="0">x, err1 := strconv.Atoi(args[0])
        y, err2 := strconv.Atoi(args[1])

        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return "Invalid coordinates"
        }</span>

        <span class="cov0" title="0">if x &lt; 0 || x &gt;= c.Level.Width || y &lt; 0 || y &gt;= c.Level.Height </span><span class="cov0" title="0">{
                return fmt.Sprintf("Coordinates out of bounds (0--%d, 0--%d)", c.Level.Width-1, c.Level.Height-1)
        }</span>

        <span class="cov0" title="0">oldX, oldY := c.Player.Position.X, c.Player.Position.Y
        c.Player.Position.X = x
        c.Player.Position.Y = y

        return fmt.Sprintf("Teleported from (%d, %d) to (%d, %d)", oldX, oldY, x, y)</span>
}

// createCommand creates items
func (c *CLIMode) createCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: create &lt;item_type&gt; [x] [y]\nTypes: weapon, armor, ring, scroll, potion, food, gold, amulet"
        }</span>

        <span class="cov0" title="0">x := c.Player.Position.X
        y := c.Player.Position.Y

        if len(args) &gt;= 3 </span><span class="cov0" title="0">{
                newX, err1 := strconv.Atoi(args[1])
                newY, err2 := strconv.Atoi(args[2])
                if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                        x, y = newX, newY
                }</span>
        }

        <span class="cov0" title="0">var newItem *item.Item
        itemType := strings.ToLower(args[0])

        switch itemType </span>{
        case equipmentWeapon:<span class="cov0" title="0">
                newItem = item.NewItem(x, y, item.ItemWeapon, "debug sword", 100)</span>
        case equipmentArmor:<span class="cov0" title="0">
                newItem = item.NewItem(x, y, item.ItemArmor, "debug armor", 100)</span>
        case "ring":<span class="cov0" title="0">
                newItem = item.NewRandomRing(x, y)</span>
        case "scroll":<span class="cov0" title="0">
                newItem = item.NewRandomScroll(x, y)</span>
        case "potion":<span class="cov0" title="0">
                newItem = item.NewRandomPotion(x, y)</span>
        case "food":<span class="cov0" title="0">
                newItem = item.NewFood(x, y)</span>
        case "gold":<span class="cov0" title="0">
                newItem = item.NewGold(x, y, false)</span>
        case "amulet":<span class="cov0" title="0">
                newItem = item.NewAmulet(x, y)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown item type: %s", itemType)</span>
        }

        <span class="cov0" title="0">c.Level.Items = append(c.Level.Items, newItem)
        return fmt.Sprintf("Created %s at (%d, %d)", newItem.Name, x, y)</span>
}

// killCommand kills monsters
func (c *CLIMode) killCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 || args[0] == commandAll </span><span class="cov0" title="0">{
                count := 0
                for _, monster := range c.Level.Monsters </span><span class="cov0" title="0">{
                        if monster.IsAlive() </span><span class="cov0" title="0">{
                                monster.HP = 0
                                count++
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("Killed %d monsters", count)</span>
        }

        <span class="cov0" title="0">if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                x, err1 := strconv.Atoi(args[0])
                y, err2 := strconv.Atoi(args[1])
                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return "Invalid coordinates"
                }</span>

                <span class="cov0" title="0">monster := c.Level.GetMonsterAt(x, y)
                if monster != nil &amp;&amp; monster.IsAlive() </span><span class="cov0" title="0">{
                        monster.HP = 0
                        return fmt.Sprintf("Killed monster at (%d, %d)", x, y)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("No alive monster at (%d, %d)", x, y)</span>
        }

        <span class="cov0" title="0">return "Usage: kill [all|&lt;x&gt; &lt;y&gt;]"</span>
}

// levelCommand changes dungeon level
func (c *CLIMode) levelCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: level &lt;floor&gt;"
        }</span>

        <span class="cov0" title="0">floor, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return "Invalid floor number"
        }</span>

        // TODO: Implement level changing
        <span class="cov0" title="0">return fmt.Sprintf("Level change to floor %d (TODO: implement)", floor)</span>
}

// identifyCommand identifies items
func (c *CLIMode) identifyCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 || args[0] == commandAll </span><span class="cov0" title="0">{
                // Identify all items in inventory
                count := 0
                for _, item := range c.Player.Inventory.Items </span><span class="cov0" title="0">{
                        if !c.Player.IdentifyMgr.IsIdentified(item) </span><span class="cov0" title="0">{
                                c.Player.IdentifyMgr.IdentifyItem(item)
                                count++
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("Identified %d items", count)</span>
        }

        <span class="cov0" title="0">return "Usage: identify [all|&lt;item_type&gt;]"</span>
}

// mapCommand provides map information
func (c *CLIMode) mapCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 || args[0] == "info" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Map Info:\nSize: %dx%d\nRooms: %d\nMonsters: %d\nItems: %d",
                        c.Level.Width, c.Level.Height,
                        len(c.Level.Rooms), len(c.Level.Monsters), len(c.Level.Items))
        }</span>

        <span class="cov0" title="0">if args[0] == "reveal" </span><span class="cov0" title="0">{
                // TODO: Implement map revelation
                return "Map revealed (TODO: implement)"
        }</span>

        <span class="cov0" title="0">return "Usage: map [info|reveal]"</span>
}

// inventoryCommand manages inventory
func (c *CLIMode) inventoryCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                listing := c.Player.Inventory.GetInventoryListing(c.Player.IdentifyMgr)
                return strings.Join(listing, "\n")
        }</span>

        <span class="cov0" title="0">if args[0] == "clear" </span><span class="cov0" title="0">{
                count := c.Player.Inventory.Size()
                c.Player.Inventory.Items = make([]*item.Item, 0)
                return fmt.Sprintf("Cleared %d items from inventory", count)
        }</span>

        <span class="cov0" title="0">return "Usage: inventory [clear|add &lt;item&gt;]"</span>
}

// saveCommand saves game state
func (c *CLIMode) saveCommand(args []string) string <span class="cov0" title="0">{
        filename := "debug_save.json"
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                filename = args[0]
        }</span>

        // TODO: Implement save functionality
        <span class="cov0" title="0">return fmt.Sprintf("Game saved to %s (TODO: implement)", filename)</span>
}

// loadCommand loads game state
func (c *CLIMode) loadCommand(args []string) string <span class="cov0" title="0">{
        filename := "debug_save.json"
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                filename = args[0]
        }</span>

        // TODO: Implement load functionality
        <span class="cov0" title="0">return fmt.Sprintf("Game loaded from %s (TODO: implement)", filename)</span>
}

// setCommand sets player attributes
func (c *CLIMode) setCommand(args []string) string <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return "Usage: set &lt;attribute&gt; &lt;value&gt;\nAttributes: level, hp, maxhp, attack, defense, hunger"
        }</span>

        <span class="cov0" title="0">attribute := strings.ToLower(args[0])
        value, err := strconv.Atoi(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return "Invalid value"
        }</span>

        <span class="cov0" title="0">switch attribute </span>{
        case "level":<span class="cov0" title="0">
                c.Player.Level = value</span>
        case "hp":<span class="cov0" title="0">
                c.Player.HP = value</span>
        case "maxhp":<span class="cov0" title="0">
                c.Player.MaxHP = value</span>
        case "attack":<span class="cov0" title="0">
                c.Player.Attack = value</span>
        case "defense":<span class="cov0" title="0">
                c.Player.Defense = value</span>
        case "hunger":<span class="cov0" title="0">
                c.Player.Hunger = value</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown attribute: %s", attribute)</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("Set %s to %d", attribute, value)</span>
}

// spawnCommand spawns monsters
func (c *CLIMode) spawnCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: spawn &lt;monster_type&gt; [x] [y] [count]"
        }</span>

        // TODO: Implement monster spawning
        <span class="cov0" title="0">return fmt.Sprintf("Spawned %s (TODO: implement)", args[0])</span>
}

// debugCommand provides debug information
func (c *CLIMode) debugCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: debug [memory|performance|entities]"
        }</span>

        <span class="cov0" title="0">switch args[0] </span>{
        case "memory":<span class="cov0" title="0">
                return "Memory usage: TODO"</span>
        case "performance":<span class="cov0" title="0">
                return "Performance stats: TODO"</span>
        case "entities":<span class="cov0" title="0">
                return fmt.Sprintf("Entities:\nPlayer: (%d, %d)\nMonsters: %d\nItems: %d",
                        c.Player.Position.X, c.Player.Position.Y,
                        len(c.Level.Monsters), len(c.Level.Items))</span>
        default:<span class="cov0" title="0">
                return "Unknown debug option"</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cli

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/game/magic"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

const invalidItemLetterMsg = "Invalid item letter. Use a-z."

// registerGameCommands registers PyRogue-style game commands
func (c *CLIMode) registerGameCommands() <span class="cov8" title="1">{
        gameCommands := []*Command{
                {
                        Name:        "move",
                        Description: "Move player in direction",
                        Usage:       "move &lt;direction&gt;",
                        Handler:     c.moveCommand,
                },
                {
                        Name:        "pickup",
                        Description: "Pick up item at current position",
                        Usage:       "pickup [all]",
                        Handler:     c.pickupCommand,
                },
                {
                        Name:        "drop",
                        Description: "Drop item from inventory",
                        Usage:       "drop &lt;item_letter&gt;",
                        Handler:     c.dropCommand,
                },
                {
                        Name:        "equip",
                        Description: "Equip item from inventory",
                        Usage:       "equip &lt;item_letter&gt;",
                        Handler:     c.equipCommand,
                },
                {
                        Name:        "unequip",
                        Description: "Unequip item",
                        Usage:       "unequip &lt;slot&gt;",
                        Handler:     c.unequipCommand,
                },
                {
                        Name:        "use",
                        Description: "Use item (potion/scroll)",
                        Usage:       "use &lt;item_letter&gt;",
                        Handler:     c.useCommand,
                },
                {
                        Name:        "attack",
                        Description: "Attack monster at position",
                        Usage:       "attack &lt;x&gt; &lt;y&gt;",
                        Handler:     c.attackCommand,
                },
                {
                        Name:        "look",
                        Description: "Look at position or examine item",
                        Usage:       "look [x] [y]",
                        Handler:     c.lookCommand,
                },
                {
                        Name:        "rest",
                        Description: "Rest for specified turns",
                        Usage:       "rest [turns]",
                        Handler:     c.restCommand,
                },
                {
                        Name:        "search",
                        Description: "Search for hidden doors/traps",
                        Usage:       "search",
                        Handler:     c.searchCommand,
                },
                {
                        Name:        "open",
                        Description: "Open door at direction",
                        Usage:       "open &lt;direction&gt;",
                        Handler:     c.openCommand,
                },
                {
                        Name:        "close",
                        Description: "Close door at direction",
                        Usage:       "close &lt;direction&gt;",
                        Handler:     c.closeCommand,
                },
                {
                        Name:        "stairs",
                        Description: "Use stairs (up/down)",
                        Usage:       "stairs &lt;up|down&gt;",
                        Handler:     c.stairsCommand,
                },
                {
                        Name:        "auto",
                        Description: "Auto-explore or auto-pickup",
                        Usage:       "auto &lt;explore|pickup&gt;",
                        Handler:     c.autoCommand,
                },
                {
                        Name:        "game",
                        Description: "Game control commands",
                        Usage:       "game &lt;new|save|load|quit&gt;",
                        Handler:     c.gameCommand,
                },
        }

        for _, cmd := range gameCommands </span><span class="cov8" title="1">{
                c.Commands[cmd.Name] = cmd
        }</span>
}

// moveCommand moves the player
func (c *CLIMode) moveCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: move &lt;direction&gt;\nDirections: n, s, e, w, ne, nw, se, sw, up, down"
        }</span>

        <span class="cov0" title="0">var dx, dy int
        direction := strings.ToLower(args[0])

        switch direction </span>{
        case "n", "north", "up", "k":<span class="cov0" title="0">
                dx, dy = 0, -1</span>
        case "s", "south", "down", "j":<span class="cov0" title="0">
                dx, dy = 0, 1</span>
        case "e", "east", "right", "l":<span class="cov0" title="0">
                dx, dy = 1, 0</span>
        case "w", "west", "left", "h":<span class="cov0" title="0">
                dx, dy = -1, 0</span>
        case "ne", "northeast", "u":<span class="cov0" title="0">
                dx, dy = 1, -1</span>
        case "nw", "northwest", "y":<span class="cov0" title="0">
                dx, dy = -1, -1</span>
        case "se", "southeast", "m":<span class="cov0" title="0">
                dx, dy = 1, 1</span>
        case "sw", "southwest", "b":<span class="cov0" title="0">
                dx, dy = -1, 1</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown direction: %s", direction)</span>
        }

        <span class="cov0" title="0">oldX, oldY := c.Player.Position.X, c.Player.Position.Y
        newX, newY := oldX+dx, oldY+dy

        // Check bounds
        if newX &lt; 0 || newX &gt;= c.Level.Width || newY &lt; 0 || newY &gt;= c.Level.Height </span><span class="cov0" title="0">{
                return "Cannot move out of bounds"
        }</span>

        // Check for walls (simplified)
        <span class="cov0" title="0">tile := c.Level.GetTile(newX, newY)
        if tile != nil &amp;&amp; !tile.Walkable() </span><span class="cov0" title="0">{
                return "Cannot move there - blocked"
        }</span>

        // Check for monsters
        <span class="cov0" title="0">monster := c.Level.GetMonsterAt(newX, newY)
        if monster != nil &amp;&amp; monster.IsAlive() </span><span class="cov0" title="0">{
                // Attack instead of move
                damage := c.Player.CalculateDamage(monster.Defense)
                monster.TakeDamage(damage)

                if monster.IsAlive() </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Attacked %s for %d damage! (%d HP remaining)",
                                monster.Type.Name, damage, monster.HP)
                }</span> else<span class="cov0" title="0"> {
                        exp := monster.MaxHP + monster.Attack
                        c.Player.GainExp(exp)
                        return fmt.Sprintf("Killed %s! Gained %d experience.", monster.Type.Name, exp)
                }</span>
        }

        // Move player
        <span class="cov0" title="0">c.Player.Position.X = newX
        c.Player.Position.Y = newY

        logger.Debug("Player moved via CLI", "from", fmt.Sprintf("(%d,%d)", oldX, oldY),
                "to", fmt.Sprintf("(%d,%d)", newX, newY))

        return fmt.Sprintf("Moved %s to (%d, %d)", direction, newX, newY)</span>
}

// pickupCommand picks up items
func (c *CLIMode) pickupCommand(args []string) string <span class="cov0" title="0">{
        currentPos := c.Player.Position
        itemsAtPos := make([]*item.Item, 0)

        // Find items at current position
        for _, itm := range c.Level.Items </span><span class="cov0" title="0">{
                if itm.Position.X == currentPos.X &amp;&amp; itm.Position.Y == currentPos.Y </span><span class="cov0" title="0">{
                        itemsAtPos = append(itemsAtPos, itm)
                }</span>
        }

        <span class="cov0" title="0">if len(itemsAtPos) == 0 </span><span class="cov0" title="0">{
                return "No items here to pick up."
        }</span>

        <span class="cov0" title="0">if len(args) &gt; 0 &amp;&amp; args[0] == "all" </span><span class="cov0" title="0">{
                // Pick up all items
                pickedUp := 0
                for _, itm := range itemsAtPos </span><span class="cov0" title="0">{
                        if c.Player.Inventory.AddItem(itm) </span><span class="cov0" title="0">{
                                c.Level.RemoveItem(itm)
                                pickedUp++
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("Picked up %d items.", pickedUp)</span>
        }

        // Pick up first item
        <span class="cov0" title="0">itm := itemsAtPos[0]
        if c.Player.Inventory.AddItem(itm) </span><span class="cov0" title="0">{
                c.Level.RemoveItem(itm)
                displayName := c.Player.IdentifyMgr.GetDisplayName(itm)
                return fmt.Sprintf("Picked up %s.", displayName)
        }</span>

        <span class="cov0" title="0">return "Inventory is full!"</span>
}

// dropCommand drops items
func (c *CLIMode) dropCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: drop &lt;item_letter&gt;\nExample: drop a"
        }</span>

        <span class="cov0" title="0">letter := args[0]
        if len(letter) != 1 || letter[0] &lt; 'a' || letter[0] &gt; 'z' </span><span class="cov0" title="0">{
                return invalidItemLetterMsg
        }</span>

        <span class="cov0" title="0">index := int(letter[0] - 'a')
        itm := c.Player.Inventory.GetItem(index)
        if itm == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("No item at slot %s.", letter)
        }</span>

        // Set item position to player position
        <span class="cov0" title="0">itm.Position.X = c.Player.Position.X
        itm.Position.Y = c.Player.Position.Y

        // Add to level items
        c.Level.Items = append(c.Level.Items, itm)

        // Remove from inventory
        c.Player.Inventory.RemoveItem(index)

        displayName := c.Player.IdentifyMgr.GetDisplayName(itm)
        return fmt.Sprintf("Dropped %s.", displayName)</span>
}

// equipCommand equips items
func (c *CLIMode) equipCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: equip &lt;item_letter&gt;\nExample: equip a"
        }</span>

        <span class="cov0" title="0">letter := args[0]
        if len(letter) != 1 || letter[0] &lt; 'a' || letter[0] &gt; 'z' </span><span class="cov0" title="0">{
                return invalidItemLetterMsg
        }</span>

        <span class="cov0" title="0">index := int(letter[0] - 'a')
        itm := c.Player.Inventory.GetItem(index)
        if itm == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("No item at slot %s.", letter)
        }</span>

        // Check if item can be equipped
        <span class="cov0" title="0">canEquip := false
        switch itm.Type </span>{
        case item.ItemWeapon, item.ItemArmor, item.ItemRing:<span class="cov0" title="0">
                canEquip = true</span>
        }

        <span class="cov0" title="0">if !canEquip </span><span class="cov0" title="0">{
                return "That item cannot be equipped."
        }</span>

        // Try to equip
        <span class="cov0" title="0">if c.Player.Equipment.EquipItem(itm) </span><span class="cov0" title="0">{
                c.Player.Inventory.RemoveItem(index)
                displayName := c.Player.IdentifyMgr.GetDisplayName(itm)
                return fmt.Sprintf("Equipped %s.", displayName)
        }</span>

        <span class="cov0" title="0">return "Cannot equip that item (slot occupied?)."</span>
}

// unequipCommand unequips items
func (c *CLIMode) unequipCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: unequip &lt;slot&gt;\nSlots: weapon, armor, ring-left, ring-right"
        }</span>

        <span class="cov0" title="0">slot := strings.ToLower(args[0])
        var slotName string

        switch slot </span>{
        case "weapon", "w":<span class="cov0" title="0">
                slotName = "weapon"</span>
        case "armor", "a":<span class="cov0" title="0">
                slotName = "armor"</span>
        case "ring-left", "left", "l":<span class="cov0" title="0">
                slotName = "ring_left"</span>
        case "ring-right", "right", "r":<span class="cov0" title="0">
                slotName = "ring_right"</span>
        default:<span class="cov0" title="0">
                return "Unknown slot. Use: weapon, armor, ring-left, ring-right"</span>
        }

        <span class="cov0" title="0">itm := c.Player.Equipment.UnequipItem(slotName)
        if itm == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("No item equipped in %s slot.", slot)
        }</span>

        <span class="cov0" title="0">if c.Player.Inventory.AddItem(itm) </span><span class="cov0" title="0">{
                displayName := c.Player.IdentifyMgr.GetDisplayName(itm)
                return fmt.Sprintf("Unequipped %s.", displayName)
        }</span>

        // Inventory full, re-equip item
        <span class="cov0" title="0">c.Player.Equipment.EquipItem(itm)
        return "Inventory is full! Cannot unequip."</span>
}

// useCommand uses items
func (c *CLIMode) useCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: use &lt;item_letter&gt;\nExample: use a"
        }</span>

        <span class="cov0" title="0">letter := args[0]
        if len(letter) != 1 || letter[0] &lt; 'a' || letter[0] &gt; 'z' </span><span class="cov0" title="0">{
                return invalidItemLetterMsg
        }</span>

        <span class="cov0" title="0">index := int(letter[0] - 'a')
        itm := c.Player.Inventory.GetItem(index)
        if itm == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("No item at slot %s.", letter)
        }</span>

        <span class="cov0" title="0">var result *magic.EffectResult

        switch itm.Type </span>{
        case item.ItemPotion:<span class="cov0" title="0">
                result = magic.UsePotion(itm.Name, c.Player)</span>
        case item.ItemScroll:<span class="cov0" title="0">
                result = magic.UseScroll(itm.Name, c.Player, c.Level)</span>
        case item.ItemFood:<span class="cov0" title="0">
                c.Player.Hunger = 100
                result = &amp;magic.EffectResult{
                        Message:    "You eat the food and feel satisfied.",
                        Success:    true,
                        Identified: true,
                }</span>
        default:<span class="cov0" title="0">
                return "That item cannot be used."</span>
        }

        <span class="cov0" title="0">if result.Identified </span><span class="cov0" title="0">{
                c.Player.IdentifyMgr.IdentifyByUse(itm)
        }</span>

        // Remove item from inventory
        <span class="cov0" title="0">c.Player.Inventory.RemoveItem(index)

        return result.Message</span>
}

// attackCommand attacks monsters
func (c *CLIMode) attackCommand(args []string) string <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return "Usage: attack &lt;x&gt; &lt;y&gt;"
        }</span>

        <span class="cov0" title="0">x, err1 := strconv.Atoi(args[0])
        y, err2 := strconv.Atoi(args[1])

        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return "Invalid coordinates."
        }</span>

        <span class="cov0" title="0">monster := c.Level.GetMonsterAt(x, y)
        if monster == nil || !monster.IsAlive() </span><span class="cov0" title="0">{
                return fmt.Sprintf("No monster at (%d, %d).", x, y)
        }</span>

        <span class="cov0" title="0">damage := c.Player.CalculateDamage(monster.Defense)
        monster.TakeDamage(damage)

        if monster.IsAlive() </span><span class="cov0" title="0">{
                return fmt.Sprintf("Attacked %s for %d damage! (%d HP remaining)",
                        monster.Type.Name, damage, monster.HP)
        }</span> else<span class="cov0" title="0"> {
                exp := monster.MaxHP + monster.Attack
                c.Player.GainExp(exp)
                return fmt.Sprintf("Killed %s! Gained %d experience.", monster.Type.Name, exp)
        }</span>
}

// lookCommand examines positions or items
func (c *CLIMode) lookCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                // Look at current position
                x, y := c.Player.Position.X, c.Player.Position.Y
                return c.describeTile(x, y)
        }</span>

        <span class="cov0" title="0">if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                x, err1 := strconv.Atoi(args[0])
                y, err2 := strconv.Atoi(args[1])

                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return "Invalid coordinates."
                }</span>

                <span class="cov0" title="0">return c.describeTile(x, y)</span>
        }

        <span class="cov0" title="0">return "Usage: look [x] [y]"</span>
}

// describeTile describes what's at a tile
func (c *CLIMode) describeTile(x, y int) string <span class="cov0" title="0">{
        if x &lt; 0 || x &gt;= c.Level.Width || y &lt; 0 || y &gt;= c.Level.Height </span><span class="cov0" title="0">{
                return "Out of bounds."
        }</span>

        <span class="cov0" title="0">description := fmt.Sprintf("Position (%d, %d):\n", x, y)

        // Tile info
        tile := c.Level.GetTile(x, y)
        if tile != nil </span><span class="cov0" title="0">{
                description += fmt.Sprintf("Terrain: %s\n", tile.Type.String())
        }</span>

        // Monster info
        <span class="cov0" title="0">monster := c.Level.GetMonsterAt(x, y)
        if monster != nil &amp;&amp; monster.IsAlive() </span><span class="cov0" title="0">{
                description += fmt.Sprintf("Monster: %s (HP: %d/%d)\n",
                        monster.Type.Name, monster.HP, monster.MaxHP)
        }</span>

        // Item info
        <span class="cov0" title="0">itemsHere := make([]*item.Item, 0)
        for _, itm := range c.Level.Items </span><span class="cov0" title="0">{
                if itm.Position.X == x &amp;&amp; itm.Position.Y == y </span><span class="cov0" title="0">{
                        itemsHere = append(itemsHere, itm)
                }</span>
        }

        <span class="cov0" title="0">if len(itemsHere) &gt; 0 </span><span class="cov0" title="0">{
                description += "Items: "
                for i, itm := range itemsHere </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                description += ", "
                        }</span>
                        <span class="cov0" title="0">displayName := c.Player.IdentifyMgr.GetDisplayName(itm)
                        description += displayName</span>
                }
                <span class="cov0" title="0">description += "\n"</span>
        }

        <span class="cov0" title="0">return strings.TrimSpace(description)</span>
}

// restCommand rests for turns
func (c *CLIMode) restCommand(args []string) string <span class="cov0" title="0">{
        turns := 1
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                if t, err := strconv.Atoi(args[0]); err == nil &amp;&amp; t &gt; 0 </span><span class="cov0" title="0">{
                        turns = t
                }</span>
        }

        <span class="cov0" title="0">if turns &gt; 100 </span><span class="cov0" title="0">{
                turns = 100 // Safety limit
        }</span>

        <span class="cov0" title="0">healAmount := turns / 5 // Heal slowly while resting
        if healAmount &gt; 0 </span><span class="cov0" title="0">{
                c.Player.Heal(healAmount)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("Rested for %d turns. (Healed %d HP)", turns, healAmount)</span>
}

// searchCommand searches for hidden things
func (c *CLIMode) searchCommand(args []string) string <span class="cov0" title="0">{
        // TODO: Implement search functionality
        return "You search carefully but find nothing hidden."
}</span>

// openCommand opens doors
func (c *CLIMode) openCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: open &lt;direction&gt;"
        }</span>

        // TODO: Implement door opening
        <span class="cov0" title="0">return fmt.Sprintf("Attempted to open door to the %s. (TODO: implement doors)", args[0])</span>
}

// closeCommand closes doors
func (c *CLIMode) closeCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: close &lt;direction&gt;"
        }</span>

        // TODO: Implement door closing
        <span class="cov0" title="0">return fmt.Sprintf("Attempted to close door to the %s. (TODO: implement doors)", args[0])</span>
}

// stairsCommand uses stairs
func (c *CLIMode) stairsCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: stairs &lt;up|down&gt;"
        }</span>

        <span class="cov0" title="0">direction := strings.ToLower(args[0])

        switch direction </span>{
        case "up", "u":<span class="cov0" title="0">
                return "Climbed up the stairs. (TODO: implement level changing)"</span>
        case "down", "d":<span class="cov0" title="0">
                return "Descended down the stairs. (TODO: implement level changing)"</span>
        default:<span class="cov0" title="0">
                return "Usage: stairs &lt;up|down&gt;"</span>
        }
}

// autoCommand provides automation
func (c *CLIMode) autoCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: auto &lt;explore|pickup&gt;"
        }</span>

        <span class="cov0" title="0">action := strings.ToLower(args[0])

        switch action </span>{
        case "explore":<span class="cov0" title="0">
                return "Auto-explore started. (TODO: implement auto-explore)"</span>
        case "pickup":<span class="cov0" title="0">
                return c.pickupCommand([]string{"all"})</span>
        default:<span class="cov0" title="0">
                return "Usage: auto &lt;explore|pickup&gt;"</span>
        }
}

// gameCommand handles game control
func (c *CLIMode) gameCommand(args []string) string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return "Usage: game &lt;new|save|load|quit&gt;"
        }</span>

        <span class="cov0" title="0">action := strings.ToLower(args[0])

        switch action </span>{
        case "new":<span class="cov0" title="0">
                return "Starting new game. (TODO: implement new game)"</span>
        case "save":<span class="cov0" title="0">
                filename := "savegame.json"
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        filename = args[1]
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Game saved to %s. (TODO: implement save)", filename)</span>
        case "load":<span class="cov0" title="0">
                filename := "savegame.json"
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        filename = args[1]
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Game loaded from %s. (TODO: implement load)", filename)</span>
        case "quit":<span class="cov0" title="0">
                return "Use 'quit' or 'exit' to quit CLI."</span>
        default:<span class="cov0" title="0">
                return "Usage: game &lt;new|save|load|quit&gt;"</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package core

import (
        "github.com/anaseto/gruid"
        "github.com/yuru-sha/gorogue/internal/core/state"
        "github.com/yuru-sha/gorogue/internal/game/actor"
        "github.com/yuru-sha/gorogue/internal/game/dungeon"
        uiscreen "github.com/yuru-sha/gorogue/internal/ui/screen"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

const (
        screenWidth  = 80
        screenHeight = 50
)

// Engine represents the game engine and implements gruid.Model interface
type Engine struct {
        grid           gruid.Grid
        stateManager   *state.StateManager
        dungeonManager *dungeon.DungeonManager
        player         *actor.Player
        gameScreen     *uiscreen.GameScreen
        menuScreen     *uiscreen.MenuScreen
        msgs           []gruid.Msg
}

// NewEngine creates and initializes a new game engine
func NewEngine() *Engine <span class="cov0" title="0">{
        // グリッドの初期化
        grid := gruid.NewGrid(screenWidth, screenHeight)

        // プレイヤーの生成（仮位置、後でダンジョンマネージャーが適切な位置に配置）
        player := actor.NewPlayer(0, 0)
        logger.Debug("Created player",
                "x", player.Position.X,
                "y", player.Position.Y,
        )

        // ダンジョンマネージャーの生成
        dungeonManager := dungeon.NewDungeonManager(player)

        // プレイヤーを最初の部屋の中央に配置
        level := dungeonManager.GetCurrentLevel()
        if len(level.Rooms) &gt; 0 </span><span class="cov0" title="0">{
                firstRoom := level.Rooms[0]
                player.Position.X = firstRoom.X + firstRoom.Width/2
                player.Position.Y = firstRoom.Y + firstRoom.Height/2
                logger.Debug("Placed player in first room",
                        "x", player.Position.X,
                        "y", player.Position.Y,
                        "room_x", firstRoom.X,
                        "room_y", firstRoom.Y,
                )
        }</span>

        // 画面の生成
        <span class="cov0" title="0">gameScreen := uiscreen.NewGameScreen(screenWidth, screenHeight, player)
        gameScreen.SetLevel(level)                   // ダンジョンレベルを設定
        gameScreen.SetDungeonManager(dungeonManager) // ダンジョンマネージャーを設定
        menuScreen := uiscreen.NewMenuScreen(screenWidth, screenHeight)
        logger.Debug("Created screens")

        // ステートマネージャーの初期化
        stateManager := state.NewStateManager()
        stateManager.RegisterState(state.StateMenu, menuScreen)
        stateManager.RegisterState(state.StateGame, gameScreen)

        // ゲーム状態で開始
        stateManager.SetState(state.StateGame)

        engine := &amp;Engine{
                grid:           grid,
                stateManager:   stateManager,
                dungeonManager: dungeonManager,
                player:         player,
                gameScreen:     gameScreen,
                menuScreen:     menuScreen,
                msgs:           make([]gruid.Msg, 0),
        }

        return engine</span>
}

// Update implements gruid.Model.Update
func (e *Engine) Update(msg gruid.Msg) gruid.Effect <span class="cov0" title="0">{
        e.msgs = append(e.msgs, msg)

        switch msg := msg.(type) </span>{
        case gruid.MsgInit:<span class="cov0" title="0">
                // 初期化時の処理
                return nil</span>
        case gruid.MsgKeyDown:<span class="cov0" title="0">
                // キー入力の処理
                return e.stateManager.HandleInput(msg)</span>
        case gruid.MsgQuit:<span class="cov0" title="0">
                // 終了処理
                return gruid.End()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Draw implements gruid.Model.Draw
func (e *Engine) Draw() gruid.Grid <span class="cov0" title="0">{
        // グリッドをクリア
        e.grid.Fill(gruid.Cell{Rune: ' '})

        // 現在の状態を描画
        switch e.stateManager.GetCurrentState() </span>{
        case state.StateMenu:<span class="cov0" title="0">
                e.menuScreen.Draw(&amp;e.grid)</span>
        case state.StateGame:<span class="cov0" title="0">
                e.gameScreen.Draw(&amp;e.grid)</span>
        }

        <span class="cov0" title="0">return e.grid</span>
}

// Model returns the game's model configuration
func (e *Engine) Model() gruid.Model <span class="cov0" title="0">{
        return e
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package entity

import "github.com/anaseto/gruid"

// Entity represents any object in the game world
type Entity struct {
        Position *Position
        Symbol   rune
        Color    gruid.Color
}

// NewEntity creates a new Entity
func NewEntity(x, y int, symbol rune, color gruid.Color) *Entity <span class="cov0" title="0">{
        return &amp;Entity{
                Position: NewPosition(x, y),
                Symbol:   symbol,
                Color:    color,
        }
}</span>

// Move moves the entity by the given delta
func (e *Entity) Move(dx, dy int) <span class="cov0" title="0">{
        e.Position.Move(dx, dy)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package entity

// Position represents the position of an entity in the game world
type Position struct {
        X, Y int
}

// NewPosition creates a new Position
func NewPosition(x, y int) *Position <span class="cov0" title="0">{
        return &amp;Position{X: x, Y: y}
}</span>

// Move updates the position by the given delta
func (p *Position) Move(dx, dy int) <span class="cov0" title="0">{
        p.X += dx
        p.Y += dy
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package state

import "github.com/anaseto/gruid"

// GameState represents the current state of the game
type GameState int

const (
        StateMenu GameState = iota
        StateGame
        StateInventory
        StateHelp
        StateGameOver
)

// State represents a game state interface
type State interface {
        HandleInput(msg gruid.Msg) GameState
        Draw(grid *gruid.Grid)
}

// StateManager manages game states
type StateManager struct {
        currentState GameState
        states       map[GameState]State
}

// NewStateManager creates a new state manager
func NewStateManager() *StateManager <span class="cov0" title="0">{
        return &amp;StateManager{
                currentState: StateMenu,
                states:       make(map[GameState]State),
        }
}</span>

// RegisterState registers a state handler
func (sm *StateManager) RegisterState(state GameState, handler State) <span class="cov0" title="0">{
        sm.states[state] = handler
}</span>

// GetCurrentState returns the current state
func (sm *StateManager) GetCurrentState() GameState <span class="cov0" title="0">{
        return sm.currentState
}</span>

// SetState sets the current state
func (sm *StateManager) SetState(state GameState) <span class="cov0" title="0">{
        sm.currentState = state
}</span>

// HandleInput handles input for the current state
func (sm *StateManager) HandleInput(msg gruid.Msg) gruid.Effect <span class="cov0" title="0">{
        if handler, exists := sm.states[sm.currentState]; exists </span><span class="cov0" title="0">{
                sm.currentState = handler.HandleInput(msg)
                if sm.currentState == StateGameOver </span><span class="cov0" title="0">{
                        return gruid.End()
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Draw draws the current state
func (sm *StateManager) Draw(grid *gruid.Grid) <span class="cov0" title="0">{
        if handler, exists := sm.states[sm.currentState]; exists </span><span class="cov0" title="0">{
                handler.Draw(grid)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package wizard

import (
        "fmt"

        "github.com/yuru-sha/gorogue/internal/game/actor"
        "github.com/yuru-sha/gorogue/internal/game/dungeon"
        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// WizardMode handles wizard mode functionality
type WizardMode struct {
        IsActive bool
        Level    *dungeon.Level
        Player   *actor.Player
}

// NewWizardMode creates a new wizard mode instance
func NewWizardMode(level *dungeon.Level, player *actor.Player) *WizardMode <span class="cov0" title="0">{
        return &amp;WizardMode{
                IsActive: false,
                Level:    level,
                Player:   player,
        }
}</span>

// Toggle toggles wizard mode on/off
func (w *WizardMode) Toggle() <span class="cov0" title="0">{
        w.IsActive = !w.IsActive
        status := "OFF"
        if w.IsActive </span><span class="cov0" title="0">{
                status = "ON"
        }</span>
        <span class="cov0" title="0">logger.Info("Wizard mode toggled", "status", status)</span>
}

// SetLevel updates the level reference for wizard mode
func (w *WizardMode) SetLevel(level *dungeon.Level) <span class="cov0" title="0">{
        w.Level = level
        logger.Debug("Wizard mode level updated")
}</span>

// ExecuteCommand executes a wizard command
func (w *WizardMode) ExecuteCommand(command rune) string <span class="cov0" title="0">{
        if !w.IsActive </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">switch command </span>{
        case 'h':<span class="cov0" title="0"> // Help
                return w.showHelp()</span>
        case 'g':<span class="cov0" title="0"> // Grant gold
                return w.grantGold()</span>
        case 'l':<span class="cov0" title="0"> // Level up
                return w.levelUp()</span>
        case 'r':<span class="cov0" title="0"> // Full heal
                return w.fullHeal()</span>
        case 'f':<span class="cov0" title="0"> // Full food
                return w.fullFood()</span>
        case 'k':<span class="cov0" title="0"> // Kill all monsters
                return w.killAllMonsters()</span>
        case 's':<span class="cov0" title="0"> // Show stats
                return w.showStats()</span>
        case 'i':<span class="cov0" title="0"> // Create item
                return w.createItem()</span>
        case 't':<span class="cov0" title="0"> // Teleport
                return w.teleport()</span>
        case 'v':<span class="cov0" title="0"> // Toggle visibility
                return w.toggleVisibility()</span>
        case 'w':<span class="cov0" title="0"> // Walk through walls
                return w.toggleWalkThroughWalls()</span>
        default:<span class="cov0" title="0">
                return "不明なウィザードコマンド"</span>
        }
}

// showHelp displays wizard mode help
func (w *WizardMode) showHelp() string <span class="cov0" title="0">{
        return "ウィザードモード: h=ヘルプ g=ゴールド l=レベルアップ r=回復 f=満腹 k=全モンスター撃破 s=ステータス i=アイテム作成 t=テレポート v=視界切替 w=壁通り抜け"
}</span>

// grantGold grants gold to the player
func (w *WizardMode) grantGold() string <span class="cov0" title="0">{
        w.Player.AddGold(1000)
        logger.Info("Wizard: Granted gold", "amount", 1000)
        return "1000ゴールドを取得しました"
}</span>

// levelUp levels up the player
func (w *WizardMode) levelUp() string <span class="cov0" title="0">{
        w.Player.GainExp(w.Player.GetExpToNextLevel())
        logger.Info("Wizard: Player leveled up")
        return "レベルアップしました"
}</span>

// fullHeal fully heals the player
func (w *WizardMode) fullHeal() string <span class="cov0" title="0">{
        w.Player.HP = w.Player.MaxHP
        logger.Info("Wizard: Player fully healed")
        return "完全回復しました"
}</span>

// fullFood fills the player's hunger
func (w *WizardMode) fullFood() string <span class="cov0" title="0">{
        w.Player.Hunger = 100
        logger.Info("Wizard: Player hunger restored")
        return "満腹になりました"
}</span>

// killAllMonsters kills all monsters in the level
func (w *WizardMode) killAllMonsters() string <span class="cov0" title="0">{
        count := 0
        for _, monster := range w.Level.Monsters </span><span class="cov0" title="0">{
                if monster.IsAlive() </span><span class="cov0" title="0">{
                        monster.HP = 0
                        count++
                }</span>
        }
        <span class="cov0" title="0">logger.Info("Wizard: Killed all monsters", "count", count)
        return fmt.Sprintf("すべてのモンスター（%d体）を倒しました", count)</span>
}

// showStats shows detailed player statistics
func (w *WizardMode) showStats() string <span class="cov0" title="0">{
        return fmt.Sprintf("Lv:%d HP:%d/%d Atk:%d Def:%d Exp:%d Gold:%d Hunger:%d",
                w.Player.Level, w.Player.HP, w.Player.MaxHP,
                w.Player.Attack, w.Player.Defense, w.Player.Exp,
                w.Player.Gold, w.Player.Hunger)
}</span>

// createItem creates a random item at player's position
func (w *WizardMode) createItem() string <span class="cov0" title="0">{
        items := []item.ItemType{
                item.ItemWeapon, item.ItemArmor, item.ItemRing,
                item.ItemScroll, item.ItemPotion, item.ItemFood,
                item.ItemGold, item.ItemAmulet,
        }

        itemType := items[len(items)-1] // Create amulet for testing
        var newItem *item.Item

        switch itemType </span>{
        case item.ItemGold:<span class="cov0" title="0">
                newItem = item.NewGold(w.Player.Position.X, w.Player.Position.Y, false)</span>
        case item.ItemAmulet:<span class="cov0" title="0">
                newItem = item.NewAmulet(w.Player.Position.X, w.Player.Position.Y)</span>
        default:<span class="cov0" title="0">
                newItem = item.NewItem(w.Player.Position.X, w.Player.Position.Y, itemType, "ウィザードアイテム", 100)</span>
        }

        <span class="cov0" title="0">w.Level.Items = append(w.Level.Items, newItem)
        logger.Info("Wizard: Created item", "type", newItem.Name, "x", newItem.Position.X, "y", newItem.Position.Y)
        return fmt.Sprintf("%sを作成しました", newItem.Name)</span>
}

// teleport teleports player to a random room
func (w *WizardMode) teleport() string <span class="cov0" title="0">{
        if len(w.Level.Rooms) == 0 </span><span class="cov0" title="0">{
                return "テレポート先がありません"
        }</span>

        <span class="cov0" title="0">room := w.Level.Rooms[len(w.Level.Rooms)-1] // Last room
        newX := room.X + room.Width/2
        newY := room.Y + room.Height/2

        w.Player.Position.X = newX
        w.Player.Position.Y = newY

        logger.Info("Wizard: Player teleported", "x", newX, "y", newY)
        return "テレポートしました"</span>
}

// toggleVisibility toggles all tiles visibility
func (w *WizardMode) toggleVisibility() string <span class="cov0" title="0">{
        // Toggle visibility of all tiles
        for y := 0; y &lt; w.Level.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; w.Level.Width; x++ </span><span class="cov0" title="0">{
                        tile := w.Level.GetTile(x, y)
                        if tile != nil </span><span class="cov0" title="0">{
                                tile.Visible = !tile.Visible
                        }</span>
                }
        }
        <span class="cov0" title="0">logger.Info("Wizard: Toggled visibility")
        return "視界を切り替えました"</span>
}

// toggleWalkThroughWalls toggles walk through walls ability
func (w *WizardMode) toggleWalkThroughWalls() string <span class="cov0" title="0">{
        // This would need to be implemented in the game logic
        // For now, just return a message
        logger.Info("Wizard: Wall walking toggle requested")
        return "壁通り抜けモード（未実装）"
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package actor プレイヤーとモンスターの管理を提供
// 戦闘可能なエンティティの基底クラスActorと、Player、Monster型を定義
package actor

import (
        "github.com/anaseto/gruid"
        "github.com/yuru-sha/gorogue/internal/core/entity"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// Actor represents a common base for all living entities that can fight
type Actor struct {
        *entity.Entity
        HP      int
        MaxHP   int
        Attack  int
        Defense int
}

// NewActor creates a new actor with the given stats
func NewActor(x, y int, symbol rune, color gruid.Color, hp, attack, defense int) *Actor <span class="cov8" title="1">{
        return &amp;Actor{
                Entity:  entity.NewEntity(x, y, symbol, color),
                HP:      hp,
                MaxHP:   hp,
                Attack:  attack,
                Defense: defense,
        }
}</span>

// IsAlive returns true if the actor is alive
func (a *Actor) IsAlive() bool <span class="cov8" title="1">{
        return a.HP &gt; 0
}</span>

// TakeDamage reduces the actor's HP by the given amount
func (a *Actor) TakeDamage(damage int) <span class="cov8" title="1">{
        oldHP := a.HP
        a.HP -= damage
        if a.HP &lt; 0 </span><span class="cov8" title="1">{
                a.HP = 0
        }</span>
        <span class="cov8" title="1">logger.Debug("Actor took damage",
                "damage", damage,
                "hp_before", oldHP,
                "hp_after", a.HP,
        )
        if a.HP == 0 </span><span class="cov8" title="1">{
                logger.Debug("Actor died")
        }</span>
}

// Heal restores the actor's HP by the given amount, up to MaxHP
func (a *Actor) Heal(amount int) <span class="cov8" title="1">{
        oldHP := a.HP
        a.HP += amount
        if a.HP &gt; a.MaxHP </span><span class="cov8" title="1">{
                a.HP = a.MaxHP
        }</span>
        <span class="cov8" title="1">logger.Debug("Actor healed",
                "amount", amount,
                "hp_before", oldHP,
                "hp_after", a.HP,
        )</span>
}

// CalculateDamage calculates damage dealt to a target based on this actor's attack and target's defense
func (a *Actor) CalculateDamage(targetDefense int) int <span class="cov8" title="1">{
        damage := a.Attack - targetDefense
        if damage &lt; 1 </span><span class="cov8" title="1">{
                damage = 1 // Minimum 1 damage
        }</span>
        <span class="cov8" title="1">return damage</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package actor

import (
        "math"
        "math/rand"

        "github.com/anaseto/gruid"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// MonsterType represents different types of monsters
type MonsterType struct {
        Symbol  rune
        Name    string
        HP      int
        Attack  int
        Defense int
        Color   gruid.Color
        Speed   int // Turn frequency (lower is faster)
}

// Predefined monster types - PyRogue風の色設定
var MonsterTypes = map[rune]MonsterType{
        'B': {Symbol: 'B', Name: "コウモリ", HP: 10, Attack: 3, Defense: 1, Color: 0x8B4513, Speed: 1},    // Brown
        'D': {Symbol: 'D', Name: "ドラゴン", HP: 100, Attack: 20, Defense: 10, Color: 0xFF0000, Speed: 3}, // Red
        'E': {Symbol: 'E', Name: "目玉", HP: 15, Attack: 5, Defense: 2, Color: 0x00FF00, Speed: 2},      // Green
        'F': {Symbol: 'F', Name: "ファンガス", HP: 8, Attack: 2, Defense: 1, Color: 0x90EE90, Speed: 4},    // LightGreen
        'G': {Symbol: 'G', Name: "ゴブリン", HP: 20, Attack: 6, Defense: 3, Color: 0x32CD32, Speed: 2},    // LimeGreen
        'O': {Symbol: 'O', Name: "オーク", HP: 25, Attack: 8, Defense: 4, Color: 0x696969, Speed: 2},     // DimGray
        'S': {Symbol: 'S', Name: "スケルトン", HP: 18, Attack: 7, Defense: 3, Color: 0xF5F5DC, Speed: 2},   // Beige
        'T': {Symbol: 'T', Name: "トロル", HP: 50, Attack: 12, Defense: 6, Color: 0x8B4513, Speed: 3},    // Brown
}

// Monster represents a monster in the game
type Monster struct {
        *Actor
        Type      MonsterType
        TurnCount int  // Turn management
        IsActive  bool // Active state
}

// NewMonster creates a new monster of the given type at the specified position
func NewMonster(x, y int, monsterType rune) *Monster <span class="cov0" title="0">{
        mType := MonsterTypes[monsterType]
        monster := &amp;Monster{
                Actor:     NewActor(x, y, mType.Symbol, mType.Color, mType.HP, mType.Attack, mType.Defense),
                Type:      mType,
                TurnCount: 0,
                IsActive:  true,
        }

        logger.Debug("Created new monster",
                "type", mType.Name,
                "x", x,
                "y", y,
                "hp", mType.HP,
                "attack", mType.Attack,
                "defense", mType.Defense,
        )

        return monster
}</span>

// LevelCollisionChecker is an interface for collision detection
type LevelCollisionChecker interface {
        IsInBounds(x, y int) bool
        IsWalkable(x, y int) bool
        GetMonsterAt(x, y int) *Monster
}

// Update handles monster AI logic
func (m *Monster) Update(player *Player, level LevelCollisionChecker) <span class="cov0" title="0">{
        if !m.IsActive || !m.IsAlive() </span><span class="cov0" title="0">{
                return
        }</span>

        // Turn management
        <span class="cov0" title="0">m.TurnCount++
        if m.TurnCount &lt; m.Type.Speed </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.TurnCount = 0

        // Calculate distance to player
        distance := m.DistanceToPlayer(player)

        // Attack if adjacent
        if distance &lt;= 1.5 </span><span class="cov0" title="0">{
                m.AttackPlayer(player)
                return
        }</span>

        // Move towards player
        <span class="cov0" title="0">m.MoveTowardsPlayer(player, level)</span>
}

// DistanceToPlayer calculates the distance to the player
func (m *Monster) DistanceToPlayer(player *Player) float64 <span class="cov0" title="0">{
        dx := float64(m.Position.X - player.Position.X)
        dy := float64(m.Position.Y - player.Position.Y)
        return math.Sqrt(dx*dx + dy*dy)
}</span>

// AttackPlayer performs an attack on the player
func (m *Monster) AttackPlayer(player *Player) <span class="cov0" title="0">{
        damage := m.CalculateDamage(player.Defense)
        player.TakeDamage(damage)

        logger.Info("Monster attacked player",
                "monster", m.Type.Name,
                "damage", damage,
                "player_hp", player.HP,
        )
}</span>

// MoveTowardsPlayer moves the monster towards the player
func (m *Monster) MoveTowardsPlayer(player *Player, level LevelCollisionChecker) <span class="cov0" title="0">{
        dx := 0
        dy := 0

        if m.Position.X &lt; player.Position.X </span><span class="cov0" title="0">{
                dx = 1
        }</span> else<span class="cov0" title="0"> if m.Position.X &gt; player.Position.X </span><span class="cov0" title="0">{
                dx = -1
        }</span>

        <span class="cov0" title="0">if m.Position.Y &lt; player.Position.Y </span><span class="cov0" title="0">{
                dy = 1
        }</span> else<span class="cov0" title="0"> if m.Position.Y &gt; player.Position.Y </span><span class="cov0" title="0">{
                dy = -1
        }</span>

        // Add random element (25% chance to move in different direction)
        <span class="cov0" title="0">if rand.Float32() &lt; 0.25 </span><span class="cov0" title="0">{
                directions := []struct{ dx, dy int }{
                        {-1, -1}, {-1, 0}, {-1, 1},
                        {0, -1}, {0, 1},
                        {1, -1}, {1, 0}, {1, 1},
                }
                if len(directions) &gt; 0 </span><span class="cov0" title="0">{
                        dir := directions[rand.Intn(len(directions))]
                        dx = dir.dx
                        dy = dir.dy
                }</span>
        }

        <span class="cov0" title="0">if dx != 0 || dy != 0 </span><span class="cov0" title="0">{
                // Calculate new position
                newX := m.Position.X + dx
                newY := m.Position.Y + dy

                // Check if movement is possible
                if m.CanMoveTo(newX, newY, level) </span><span class="cov0" title="0">{
                        m.Position.Move(dx, dy)
                        logger.Debug("Monster moved",
                                "monster", m.Type.Name,
                                "new_x", m.Position.X,
                                "new_y", m.Position.Y,
                        )
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug("Monster movement blocked",
                                "monster", m.Type.Name,
                                "blocked_x", newX,
                                "blocked_y", newY,
                        )
                }</span>
        }
}

// CanMoveTo checks if the monster can move to the given position
func (m *Monster) CanMoveTo(x, y int, level LevelCollisionChecker) bool <span class="cov0" title="0">{
        // Boundary check
        if !level.IsInBounds(x, y) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if tile is walkable
        <span class="cov0" title="0">if !level.IsWalkable(x, y) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if another monster is present
        <span class="cov0" title="0">if level.GetMonsterAt(x, y) != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package actor

import (
        "github.com/yuru-sha/gorogue/internal/game/identification"
        "github.com/yuru-sha/gorogue/internal/game/inventory"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// Player represents the player character
type Player struct {
        *Actor
        Level       int
        Hunger      int
        Exp         int
        Gold        int
        Inventory   *inventory.Inventory
        Equipment   *inventory.Equipment
        IdentifyMgr *identification.IdentificationManager
}

// NewPlayer creates a new player at the given position
func NewPlayer(x, y int) *Player <span class="cov0" title="0">{
        player := &amp;Player{
                Actor:       NewActor(x, y, '@', 0xFFFFFF, 20, 5, 2), // White color - オリジナルローグ風
                Level:       1,
                Hunger:      100,
                Exp:         0,
                Gold:        0,
                Inventory:   inventory.NewInventory(),
                Equipment:   inventory.NewEquipment(),
                IdentifyMgr: identification.NewIdentificationManager(),
        }
        logger.Debug("Created new player",
                "position_x", x,
                "position_y", y,
                "level", player.Level,
                "hp", player.HP,
                "attack", player.Attack,
                "defense", player.Defense,
        )
        return player
}</span>

// AddGold adds gold to the player's inventory
func (p *Player) AddGold(amount int) <span class="cov0" title="0">{
        oldGold := p.Gold
        p.Gold += amount
        logger.Debug("Player collected gold",
                "amount", amount,
                "gold_before", oldGold,
                "gold_after", p.Gold,
        )
}</span>

// AddExp adds experience points and handles level up
func (p *Player) AddExp(amount int) <span class="cov0" title="0">{
        oldExp := p.Exp
        oldLevel := p.Level
        p.Exp += amount
        // TODO: Implement level up logic based on original Rogue
        logger.Debug("Player gained experience",
                "amount", amount,
                "exp_before", oldExp,
                "exp_after", p.Exp,
                "level_before", oldLevel,
                "level_after", p.Level,
        )
}</span>

// GainExp is an alias for AddExp
func (p *Player) GainExp(amount int) <span class="cov0" title="0">{
        p.AddExp(amount)
}</span>

// CalculateDamage calculates damage dealt to a target
func (p *Player) CalculateDamage(targetDefense int) int <span class="cov0" title="0">{
        // Base attack + equipment bonus - enemy defense
        totalAttack := p.Attack + p.Equipment.GetAttackBonus()
        damage := totalAttack - targetDefense
        if damage &lt; 1 </span><span class="cov0" title="0">{
                damage = 1
        }</span>
        <span class="cov0" title="0">return damage</span>
}

// GetTotalDefense returns total defense including equipment bonuses
func (p *Player) GetTotalDefense() int <span class="cov0" title="0">{
        return p.Defense + p.Equipment.GetDefenseBonus()
}</span>

// UpdateHunger decreases hunger and handles starvation
func (p *Player) UpdateHunger() <span class="cov0" title="0">{
        oldHunger := p.Hunger
        p.Hunger--
        logger.Debug("Player hunger updated",
                "hunger_before", oldHunger,
                "hunger_after", p.Hunger,
        )
        if p.Hunger &lt;= 0 </span><span class="cov0" title="0">{
                logger.Debug("Player is starving",
                        "damage", 1,
                        "hunger", p.Hunger,
                )
                p.TakeDamage(1) // Starvation damage
        }</span>
}

// GetExpToNextLevel returns experience needed to reach next level
func (p *Player) GetExpToNextLevel() int <span class="cov0" title="0">{
        // Simple formula: level * 100 experience per level
        nextLevelExp := p.Level * 100
        return nextLevelExp - p.Exp
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package dungeon

import (
        "github.com/yuru-sha/gorogue/internal/game/actor"
        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

const (
        MaxFloors     = 26 // オリジナルローグの26階層
        DungeonWidth  = 80
        DungeonHeight = 41 // 50 - 9 (UI部分)
)

// DungeonManager manages multiple dungeon levels
type DungeonManager struct {
        levels       map[int]*Level
        currentFloor int
        player       *actor.Player
}

// NewDungeonManager creates a new dungeon manager
func NewDungeonManager(player *actor.Player) *DungeonManager <span class="cov0" title="0">{
        dm := &amp;DungeonManager{
                levels:       make(map[int]*Level),
                currentFloor: 1,
                player:       player,
        }

        // 最初のレベルを生成
        dm.generateLevel(1)

        logger.Info("Created dungeon manager",
                "max_floors", MaxFloors,
                "current_floor", dm.currentFloor,
        )

        return dm
}</span>

// GetCurrentLevel returns the current level
func (dm *DungeonManager) GetCurrentLevel() *Level <span class="cov0" title="0">{
        return dm.levels[dm.currentFloor]
}</span>

// GetCurrentFloor returns the current floor number
func (dm *DungeonManager) GetCurrentFloor() int <span class="cov0" title="0">{
        return dm.currentFloor
}</span>

// generateLevel generates a new level for the given floor
func (dm *DungeonManager) generateLevel(floor int) *Level <span class="cov0" title="0">{
        level := NewLevel(DungeonWidth, DungeonHeight, floor)
        dm.levels[floor] = level

        logger.Info("Generated new level",
                "floor", floor,
                "width", DungeonWidth,
                "height", DungeonHeight,
        )

        return level
}</span>

// MoveToFloor moves the player to the specified floor
func (dm *DungeonManager) MoveToFloor(targetFloor int) bool <span class="cov0" title="0">{
        if targetFloor &lt; 1 || targetFloor &gt; MaxFloors </span><span class="cov0" title="0">{
                logger.Warn("Invalid floor number",
                        "target_floor", targetFloor,
                        "max_floors", MaxFloors,
                )
                return false
        }</span>

        // 対象の階層が存在しない場合は生成
        <span class="cov0" title="0">if _, exists := dm.levels[targetFloor]; !exists </span><span class="cov0" title="0">{
                dm.generateLevel(targetFloor)
        }</span>

        <span class="cov0" title="0">dm.currentFloor = targetFloor

        // プレイヤーの位置を適切な階段に設定
        dm.setPlayerPositionOnFloorChange(targetFloor)

        logger.Info("Moved to floor",
                "floor", targetFloor,
                "player_x", dm.player.Position.X,
                "player_y", dm.player.Position.Y,
        )

        return true</span>
}

// setPlayerPositionOnFloorChange sets the player position when changing floors
func (dm *DungeonManager) setPlayerPositionOnFloorChange(floor int) <span class="cov0" title="0">{
        level := dm.levels[floor]
        if len(level.Rooms) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // 階段の位置を探す
        <span class="cov0" title="0">var stairPos *Position
        for y := 0; y &lt; level.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; level.Width; x++ </span><span class="cov0" title="0">{
                        tile := level.GetTile(x, y)
                        if tile.Type == TileStairsUp || tile.Type == TileStairsDown </span><span class="cov0" title="0">{
                                stairPos = &amp;Position{X: x, Y: y}
                                break</span>
                        }
                }
                <span class="cov0" title="0">if stairPos != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if stairPos != nil </span><span class="cov0" title="0">{
                dm.player.Position.X = stairPos.X
                dm.player.Position.Y = stairPos.Y
        }</span> else<span class="cov0" title="0"> {
                // 階段が見つからない場合は最初の部屋の中央に配置
                firstRoom := level.Rooms[0]
                dm.player.Position.X = firstRoom.X + firstRoom.Width/2
                dm.player.Position.Y = firstRoom.Y + firstRoom.Height/2
        }</span>
}

// GoUpstairs moves the player up one floor
func (dm *DungeonManager) GoUpstairs() bool <span class="cov0" title="0">{
        if dm.currentFloor &lt;= 1 </span><span class="cov0" title="0">{
                logger.Debug("Already at top floor")
                return false
        }</span>

        <span class="cov0" title="0">return dm.MoveToFloor(dm.currentFloor - 1)</span>
}

// GoDownstairs moves the player down one floor
func (dm *DungeonManager) GoDownstairs() bool <span class="cov0" title="0">{
        if dm.currentFloor &gt;= MaxFloors </span><span class="cov0" title="0">{
                logger.Debug("Already at bottom floor")
                return false
        }</span>

        <span class="cov0" title="0">return dm.MoveToFloor(dm.currentFloor + 1)</span>
}

// CanGoUpstairs checks if the player can go upstairs from current position
func (dm *DungeonManager) CanGoUpstairs() bool <span class="cov0" title="0">{
        level := dm.GetCurrentLevel()
        tile := level.GetTile(dm.player.Position.X, dm.player.Position.Y)
        return tile.Type == TileStairsUp &amp;&amp; dm.currentFloor &gt; 1
}</span>

// CanGoDownstairs checks if the player can go downstairs from current position
func (dm *DungeonManager) CanGoDownstairs() bool <span class="cov0" title="0">{
        level := dm.GetCurrentLevel()
        tile := level.GetTile(dm.player.Position.X, dm.player.Position.Y)
        return tile.Type == TileStairsDown &amp;&amp; dm.currentFloor &lt; MaxFloors
}</span>

// GetFloorDifficulty returns the difficulty scaling for the given floor
func (dm *DungeonManager) GetFloorDifficulty(floor int) float64 <span class="cov0" title="0">{
        // 階層が深くなるにつれて難易度が上がる
        baseDifficulty := 1.0
        difficultyIncrease := 0.1

        return baseDifficulty + (float64(floor-1) * difficultyIncrease)
}</span>

// IsOnFinalFloor checks if the player is on the final floor
func (dm *DungeonManager) IsOnFinalFloor() bool <span class="cov0" title="0">{
        return dm.currentFloor == MaxFloors
}</span>

// PlaceAmuletOfYendor places the Amulet of Yendor on the final floor
func (dm *DungeonManager) PlaceAmuletOfYendor() <span class="cov0" title="0">{
        if dm.currentFloor != MaxFloors </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">level := dm.GetCurrentLevel()
        if len(level.Rooms) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // 最後の部屋の中央に魔除けを配置
        <span class="cov0" title="0">lastRoom := level.Rooms[len(level.Rooms)-1]
        x := lastRoom.X + lastRoom.Width/2
        y := lastRoom.Y + lastRoom.Height/2

        amulet := item.NewAmulet(x, y)
        level.Items = append(level.Items, amulet)

        logger.Info("Placed Amulet of Yendor",
                "floor", dm.currentFloor,
                "x", x,
                "y", y,
        )</span>
}

// Position represents a position in the dungeon
type Position struct {
        X, Y int
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package dungeon

import (
        "math/rand"

        "github.com/yuru-sha/gorogue/internal/game/actor"
        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

const (
        MinRoomSize = 4
        MaxRoomSize = 10
        MaxRooms    = 30
        MinRooms    = 15
)

// Room represents a room in the dungeon
type Room struct {
        X, Y          int
        Width, Height int
        IsSpecial     bool
        Connected     bool
}

// Level represents a single dungeon level
type Level struct {
        Width, Height int
        Tiles         [][]*Tile
        Rooms         []*Room
        FloorNumber   int
        Monsters      []*actor.Monster
        Items         []*item.Item
}

// NewLevel creates a new dungeon level
func NewLevel(width, height, floorNum int) *Level <span class="cov0" title="0">{
        level := &amp;Level{
                Width:       width,
                Height:      height,
                FloorNumber: floorNum,
                Rooms:       make([]*Room, 0),
                Monsters:    make([]*actor.Monster, 0),
                Items:       make([]*item.Item, 0),
        }

        // Initialize tiles with walls
        level.Tiles = make([][]*Tile, height)
        for y := range level.Tiles </span><span class="cov0" title="0">{
                level.Tiles[y] = make([]*Tile, width)
                for x := range level.Tiles[y] </span><span class="cov0" title="0">{
                        level.Tiles[y][x] = NewTile(TileWall)
                }</span>
        }

        // ダンジョンの生成
        <span class="cov0" title="0">level.Generate()

        logger.Debug("Created level",
                "width", width,
                "height", height,
                "floor", floorNum,
                "total_tiles", width*height,
        )
        return level</span>
}

// Generate generates the dungeon layout
func (l *Level) Generate() <span class="cov0" title="0">{
        // 部屋の生成
        numRooms := MinRooms + rand.Intn(MaxRooms-MinRooms+1)
        for i := 0; i &lt; numRooms; i++ </span><span class="cov0" title="0">{
                l.GenerateRoom()
        }</span>

        // 部屋の接続
        <span class="cov0" title="0">l.ConnectRooms()

        // 特別な部屋の生成
        l.GenerateSpecialRoom()

        // 階段の配置
        l.PlaceStairs()

        // モンスターの配置
        l.SpawnMonsters()

        // アイテムの配置
        l.SpawnItems()

        logger.Info("Generated dungeon level",
                "floor", l.FloorNumber,
                "rooms", len(l.Rooms),
                "monsters", len(l.Monsters),
                "items", len(l.Items),
        )</span>
}

// GenerateRoom generates a single room
func (l *Level) GenerateRoom() <span class="cov0" title="0">{
        for attempts := 0; attempts &lt; 100; attempts++ </span><span class="cov0" title="0">{
                width := MinRoomSize + rand.Intn(MaxRoomSize-MinRoomSize+1)
                height := MinRoomSize + rand.Intn(MaxRoomSize-MinRoomSize+1)
                x := 1 + rand.Intn(l.Width-width-2)
                y := 1 + rand.Intn(l.Height-height-2)

                if l.CanPlaceRoom(x, y, width, height) </span><span class="cov0" title="0">{
                        room := &amp;Room{
                                X:      x,
                                Y:      y,
                                Width:  width,
                                Height: height,
                        }
                        l.AddRoom(room)
                        return
                }</span>
        }
}

// CanPlaceRoom checks if a room can be placed at the given position
func (l *Level) CanPlaceRoom(x, y, width, height int) bool <span class="cov0" title="0">{
        // 部屋の周囲1マスも含めてチェック
        for dy := -1; dy &lt;= height; dy++ </span><span class="cov0" title="0">{
                for dx := -1; dx &lt;= width; dx++ </span><span class="cov0" title="0">{
                        nx, ny := x+dx, y+dy
                        if !l.IsInBounds(nx, ny) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">if l.GetTile(nx, ny).Type != TileWall </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

// ConnectRooms connects all rooms with corridors
func (l *Level) ConnectRooms() <span class="cov0" title="0">{
        if len(l.Rooms) &lt; 2 </span><span class="cov0" title="0">{
                return
        }</span>

        // 最初の部屋を接続済みとしてマーク
        <span class="cov0" title="0">l.Rooms[0].Connected = true

        // 残りの部屋を接続
        for i := 1; i &lt; len(l.Rooms); i++ </span><span class="cov0" title="0">{
                room := l.Rooms[i]
                // 最も近い接続済みの部屋を探す
                closestRoom := l.FindClosestConnectedRoom(room)
                if closestRoom != nil </span><span class="cov0" title="0">{
                        l.ConnectRoomPair(room, closestRoom)
                        room.Connected = true
                }</span>
        }
}

// FindClosestConnectedRoom finds the closest connected room
func (l *Level) FindClosestConnectedRoom(room *Room) *Room <span class="cov0" title="0">{
        var closest *Room
        minDist := l.Width * l.Height

        for _, other := range l.Rooms </span><span class="cov0" title="0">{
                if other == room || !other.Connected </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">dist := (room.X-other.X)*(room.X-other.X) + (room.Y-other.Y)*(room.Y-other.Y)
                if dist &lt; minDist </span><span class="cov0" title="0">{
                        minDist = dist
                        closest = other
                }</span>
        }

        <span class="cov0" title="0">return closest</span>
}

// ConnectRoomPair connects two rooms with a corridor
func (l *Level) ConnectRoomPair(r1, r2 *Room) <span class="cov0" title="0">{
        // 部屋の中心点を計算
        x1 := r1.X + r1.Width/2
        y1 := r1.Y + r1.Height/2
        x2 := r2.X + r2.Width/2
        y2 := r2.Y + r2.Height/2

        // L字型の通路を生成
        if rand.Float64() &lt; 0.5 </span><span class="cov0" title="0">{
                l.CreateHorizontalCorridor(x1, x2, y1)
                l.CreateVerticalCorridor(y1, y2, x2)
        }</span> else<span class="cov0" title="0"> {
                l.CreateVerticalCorridor(y1, y2, x1)
                l.CreateHorizontalCorridor(x1, x2, y2)
        }</span>
}

// CreateHorizontalCorridor creates a horizontal corridor
func (l *Level) CreateHorizontalCorridor(x1, x2, y int) <span class="cov0" title="0">{
        for x := min(x1, x2); x &lt;= max(x1, x2); x++ </span><span class="cov0" title="0">{
                if l.GetTile(x, y).Type == TileWall </span><span class="cov0" title="0">{
                        l.SetTile(x, y, TileFloor)
                }</span>
        }
}

// CreateVerticalCorridor creates a vertical corridor
func (l *Level) CreateVerticalCorridor(y1, y2, x int) <span class="cov0" title="0">{
        for y := min(y1, y2); y &lt;= max(y1, y2); y++ </span><span class="cov0" title="0">{
                if l.GetTile(x, y).Type == TileWall </span><span class="cov0" title="0">{
                        l.SetTile(x, y, TileFloor)
                }</span>
        }
}

// PlaceStairs places the stairs in the dungeon
func (l *Level) PlaceStairs() <span class="cov0" title="0">{
        if len(l.Rooms) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // 最初の階層では上り階段を配置しない
        <span class="cov0" title="0">if l.FloorNumber &gt; 1 </span><span class="cov0" title="0">{
                // 上り階段は最初の部屋に配置
                firstRoom := l.Rooms[0]
                l.SetTile(
                        firstRoom.X+firstRoom.Width/2,
                        firstRoom.Y+firstRoom.Height/2,
                        TileStairsUp,
                )
        }</span>

        // 最終階層では下り階段を配置しない
        <span class="cov0" title="0">if l.FloorNumber &lt; 26 </span><span class="cov0" title="0">{
                // 下り階段は最後の部屋に配置
                lastRoom := l.Rooms[len(l.Rooms)-1]
                l.SetTile(
                        lastRoom.X+lastRoom.Width/2,
                        lastRoom.Y+lastRoom.Height/2,
                        TileStairsDown,
                )
        }</span>
}

// IsInBounds checks if the given coordinates are within the level bounds
func (l *Level) IsInBounds(x, y int) bool <span class="cov0" title="0">{
        return x &gt;= 0 &amp;&amp; x &lt; l.Width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; l.Height
}</span>

// GetTile returns the tile at the given coordinates
func (l *Level) GetTile(x, y int) *Tile <span class="cov0" title="0">{
        if !l.IsInBounds(x, y) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return l.Tiles[y][x]</span>
}

// IsWalkable checks if a position is walkable
func (l *Level) IsWalkable(x, y int) bool <span class="cov0" title="0">{
        tile := l.GetTile(x, y)
        return tile != nil &amp;&amp; tile.Walkable()
}</span>

// SetTile sets the tile at the given coordinates
func (l *Level) SetTile(x, y int, tileType TileType) <span class="cov0" title="0">{
        if l.IsInBounds(x, y) </span><span class="cov0" title="0">{
                l.Tiles[y][x] = NewTile(tileType)
                logger.Debug("Set tile",
                        "x", x,
                        "y", y,
                        "tile_type", tileType,
                )
        }</span>
}

// AddRoom adds a room to the level
func (l *Level) AddRoom(room *Room) <span class="cov0" title="0">{
        // Fill room with floor tiles
        for y := room.Y; y &lt; room.Y+room.Height; y++ </span><span class="cov0" title="0">{
                for x := room.X; x &lt; room.X+room.Width; x++ </span><span class="cov0" title="0">{
                        if l.IsInBounds(x, y) </span><span class="cov0" title="0">{
                                l.SetTile(x, y, TileFloor)
                        }</span>
                }
        }

        // Add room to the list
        <span class="cov0" title="0">l.Rooms = append(l.Rooms, room)

        logger.Debug("Added room",
                "x", room.X,
                "y", room.Y,
                "width", room.Width,
                "height", room.Height,
                "is_special", room.IsSpecial,
                "total_rooms", len(l.Rooms),
        )</span>
}

// IsSpecialFloor returns whether this floor should have a special room
func (l *Level) IsSpecialFloor() bool <span class="cov0" title="0">{
        return l.FloorNumber%5 == 0
}</span>

// ShouldGenerateSpecialRoom returns whether a special room should be generated
func (l *Level) ShouldGenerateSpecialRoom() bool <span class="cov0" title="0">{
        shouldGenerate := l.IsSpecialFloor() &amp;&amp; rand.Float64() &lt; 0.10 // 10% chance
        if shouldGenerate </span><span class="cov0" title="0">{
                logger.Info("Special room generation triggered",
                        "floor", l.FloorNumber,
                )
        }</span>
        <span class="cov0" title="0">return shouldGenerate</span>
}

// Helper functions
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// SpawnMonsters spawns monsters in the dungeon
func (l *Level) SpawnMonsters() <span class="cov0" title="0">{
        if len(l.Rooms) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // 階層に応じたモンスター数を計算
        <span class="cov0" title="0">numMonsters := 5 + l.FloorNumber/2
        if numMonsters &gt; 15 </span><span class="cov0" title="0">{
                numMonsters = 15
        }</span>

        // 各部屋にモンスターを配置
        <span class="cov0" title="0">for i := 0; i &lt; numMonsters; i++ </span><span class="cov0" title="0">{
                // ランダムな部屋を選択
                room := l.Rooms[rand.Intn(len(l.Rooms))]

                // 部屋内のランダムな位置を選択
                x := room.X + 1 + rand.Intn(room.Width-2)
                y := room.Y + 1 + rand.Intn(room.Height-2)

                // その位置が床タイルかチェック
                if l.GetTile(x, y).Type != TileFloor </span><span class="cov0" title="0">{
                        i-- // 無効な位置の場合は再試行
                        continue</span>
                }

                // 既にモンスターがいないかチェック
                <span class="cov0" title="0">if l.GetMonsterAt(x, y) != nil </span><span class="cov0" title="0">{
                        i-- // 既にモンスターがいる場合は再試行
                        continue</span>
                }

                // 階層に応じたモンスターを選択
                <span class="cov0" title="0">monsterType := l.selectMonsterType()
                monster := actor.NewMonster(x, y, monsterType)

                // 階層に応じた難易度スケーリング
                l.scaleMonsterForFloor(monster)

                l.Monsters = append(l.Monsters, monster)

                logger.Debug("Spawned monster",
                        "type", monster.Type.Name,
                        "x", x,
                        "y", y,
                        "floor", l.FloorNumber,
                )</span>
        }

        <span class="cov0" title="0">logger.Info("Finished spawning monsters",
                "total_monsters", len(l.Monsters),
                "floor", l.FloorNumber,
        )</span>
}

// selectMonsterType selects a monster type based on the floor level
func (l *Level) selectMonsterType() rune <span class="cov0" title="0">{
        // 階層に応じたモンスター選択
        switch </span>{
        case l.FloorNumber &lt;= 3:<span class="cov0" title="0">
                // 浅い階層：弱いモンスター
                monsters := []rune{'B', 'F', 'G'}
                return monsters[rand.Intn(len(monsters))]</span>
        case l.FloorNumber &lt;= 8:<span class="cov0" title="0">
                // 中間階層：中程度のモンスター
                monsters := []rune{'B', 'E', 'G', 'O', 'S'}
                return monsters[rand.Intn(len(monsters))]</span>
        case l.FloorNumber &lt;= 15:<span class="cov0" title="0">
                // 深い階層：強いモンスター
                monsters := []rune{'E', 'G', 'O', 'S', 'T'}
                return monsters[rand.Intn(len(monsters))]</span>
        default:<span class="cov0" title="0">
                // 最深階層：最強のモンスター
                monsters := []rune{'O', 'S', 'T', 'D'}
                return monsters[rand.Intn(len(monsters))]</span>
        }
}

// scaleMonsterForFloor scales monster stats based on the floor level
func (l *Level) scaleMonsterForFloor(monster *actor.Monster) <span class="cov0" title="0">{
        // 基本的な階層スケーリング係数
        scaleFactor := 1.0 + float64(l.FloorNumber-1)*0.1

        // HP, 攻撃力, 防御力を階層に応じて強化
        monster.MaxHP = int(float64(monster.MaxHP) * scaleFactor)
        monster.HP = monster.MaxHP
        monster.Attack = int(float64(monster.Attack) * scaleFactor)
        monster.Defense = int(float64(monster.Defense) * scaleFactor)

        // 深い階層では追加のボーナス
        if l.FloorNumber &gt; 15 </span><span class="cov0" title="0">{
                extraBonus := float64(l.FloorNumber-15) * 0.05
                monster.MaxHP = int(float64(monster.MaxHP) * (1.0 + extraBonus))
                monster.HP = monster.MaxHP
                monster.Attack = int(float64(monster.Attack) * (1.0 + extraBonus))
                monster.Defense = int(float64(monster.Defense) * (1.0 + extraBonus))
        }</span>

        <span class="cov0" title="0">logger.Debug("Scaled monster for floor",
                "floor", l.FloorNumber,
                "type", monster.Type.Name,
                "hp", monster.HP,
                "attack", monster.Attack,
                "defense", monster.Defense,
                "scale_factor", scaleFactor,
        )</span>
}

// GetMonsterAt returns the monster at the given coordinates
func (l *Level) GetMonsterAt(x, y int) *actor.Monster <span class="cov0" title="0">{
        for _, monster := range l.Monsters </span><span class="cov0" title="0">{
                if monster.Position.X == x &amp;&amp; monster.Position.Y == y &amp;&amp; monster.IsAlive() </span><span class="cov0" title="0">{
                        return monster
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemoveMonster removes a monster from the level
func (l *Level) RemoveMonster(monster *actor.Monster) <span class="cov0" title="0">{
        for i, m := range l.Monsters </span><span class="cov0" title="0">{
                if m == monster </span><span class="cov0" title="0">{
                        l.Monsters = append(l.Monsters[:i], l.Monsters[i+1:]...)
                        logger.Debug("Removed monster",
                                "type", monster.Type.Name,
                                "x", monster.Position.X,
                                "y", monster.Position.Y,
                        )
                        break</span>
                }
        }
}

// UpdateMonsters updates all monsters in the level
func (l *Level) UpdateMonsters(player *actor.Player) <span class="cov0" title="0">{
        for _, monster := range l.Monsters </span><span class="cov0" title="0">{
                if monster.IsAlive() </span><span class="cov0" title="0">{
                        monster.Update(player, l)
                }</span>
        }

        // 死んだモンスターを削除
        <span class="cov0" title="0">l.RemoveDeadMonsters()</span>
}

// RemoveDeadMonsters removes all dead monsters from the level
func (l *Level) RemoveDeadMonsters() <span class="cov0" title="0">{
        aliveMonsters := make([]*actor.Monster, 0)
        for _, monster := range l.Monsters </span><span class="cov0" title="0">{
                if monster.IsAlive() </span><span class="cov0" title="0">{
                        aliveMonsters = append(aliveMonsters, monster)
                }</span>
        }
        <span class="cov0" title="0">l.Monsters = aliveMonsters</span>
}

// GenerateSpecialRoom generates a special room
func (l *Level) GenerateSpecialRoom() <span class="cov0" title="0">{
        // 1階では特別な部屋を生成しない
        if l.FloorNumber &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        // 5階ごとに1つの特別な部屋を生成
        <span class="cov0" title="0">if l.FloorNumber%5 != 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // 10%の確率で特別な部屋を生成
        <span class="cov0" title="0">if rand.Float64() &gt; 0.1 </span><span class="cov0" title="0">{
                return
        }</span>

        // 既に特別な部屋が存在する場合は生成しない
        <span class="cov0" title="0">for _, room := range l.Rooms </span><span class="cov0" title="0">{
                if room.IsSpecial </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // 5x5の特別な部屋を生成
        <span class="cov0" title="0">for attempts := 0; attempts &lt; 100; attempts++ </span><span class="cov0" title="0">{
                x := 1 + rand.Intn(l.Width-7)  // 5x5の部屋 + 周囲1マス
                y := 1 + rand.Intn(l.Height-7) // 5x5の部屋 + 周囲1マス

                if l.CanPlaceRoom(x, y, 5, 5) </span><span class="cov0" title="0">{
                        room := &amp;Room{
                                X:         x,
                                Y:         y,
                                Width:     5,
                                Height:    5,
                                IsSpecial: true,
                        }
                        l.AddRoom(room)

                        // 隠し扉を配置
                        l.PlaceSecretDoor(room)

                        // 部屋の内容を生成
                        l.PopulateSpecialRoom(room)

                        logger.Info("Generated special room",
                                "floor", l.FloorNumber,
                                "x", x,
                                "y", y,
                        )
                        return
                }</span>
        }
}

// PlaceSecretDoor places a secret door for a special room
func (l *Level) PlaceSecretDoor(room *Room) <span class="cov0" title="0">{
        // 部屋の4辺のいずれかにランダムに隠し扉を配置
        side := rand.Intn(4)
        var x, y int

        switch side </span>{
        case 0:<span class="cov0" title="0"> // 上辺
                x = room.X + rand.Intn(room.Width)
                y = room.Y - 1</span>
        case 1:<span class="cov0" title="0"> // 右辺
                x = room.X + room.Width
                y = room.Y + rand.Intn(room.Height)</span>
        case 2:<span class="cov0" title="0"> // 下辺
                x = room.X + rand.Intn(room.Width)
                y = room.Y + room.Height</span>
        case 3:<span class="cov0" title="0"> // 左辺
                x = room.X - 1
                y = room.Y + rand.Intn(room.Height)</span>
        }

        <span class="cov0" title="0">if l.IsInBounds(x, y) </span><span class="cov0" title="0">{
                l.SetTile(x, y, TileSecretDoor)
                logger.Debug("Placed secret door",
                        "x", x,
                        "y", y,
                )
        }</span>
}

// PopulateSpecialRoom populates a special room with content
func (l *Level) PopulateSpecialRoom(room *Room) <span class="cov0" title="0">{
        // 部屋の種類をランダムに決定
        roomType := rand.Intn(6)

        switch roomType </span>{
        case 0:<span class="cov0" title="0"> // 宝物庫
                logger.Info("Generating treasure vault")</span>
                // TODO: 宝物を配置
        case 1:<span class="cov0" title="0"> // 武器庫
                logger.Info("Generating armory")</span>
                // TODO: 武器を配置
        case 2:<span class="cov0" title="0"> // 食料庫
                logger.Info("Generating food storage")</span>
                // TODO: 食料を配置
        case 3:<span class="cov0" title="0"> // 魔物のねぐら
                logger.Info("Generating monster lair")</span>
                // TODO: モンスターを配置
        case 4:<span class="cov0" title="0"> // 実験室
                logger.Info("Generating laboratory")</span>
                // TODO: 薬を配置
        case 5:<span class="cov0" title="0"> // 図書室
                logger.Info("Generating library")</span>
                // TODO: 巻物を配置
        }
}

// SpawnItems spawns items in the level
func (l *Level) SpawnItems() <span class="cov0" title="0">{
        logger.Debug("Starting item spawning", "floor", l.FloorNumber)

        // 各部屋にアイテムを配置
        for _, room := range l.Rooms </span><span class="cov0" title="0">{
                // 通常の部屋: 30%の確率でアイテムを配置
                if rand.Float64() &lt; 0.3 </span><span class="cov0" title="0">{
                        l.spawnItemInRoom(room)
                }</span>

                // 特別な部屋: 必ずアイテムを配置
                <span class="cov0" title="0">if room.IsSpecial </span><span class="cov0" title="0">{
                        l.spawnItemInRoom(room)
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Finished spawning items",
                "total_items", len(l.Items),
                "floor", l.FloorNumber,
        )</span>
}

// spawnItemInRoom spawns an item in a specific room
func (l *Level) spawnItemInRoom(room *Room) <span class="cov0" title="0">{
        maxAttempts := 20
        for attempts := 0; attempts &lt; maxAttempts; attempts++ </span><span class="cov0" title="0">{
                // 部屋内のランダムな位置を選択
                x := room.X + rand.Intn(room.Width)
                y := room.Y + rand.Intn(room.Height)

                // その位置が有効かチェック
                if !l.IsValidItemPosition(x, y) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // アイテムタイプを選択
                <span class="cov0" title="0">itemType := l.selectItemType()

                // アイテムを生成
                var newItem *item.Item
                switch itemType </span>{
                case item.ItemGold:<span class="cov0" title="0">
                        newItem = item.NewGold(x, y, room.IsSpecial)
                        // 階層に応じてゴールドの価値を調整
                        if newItem != nil </span><span class="cov0" title="0">{
                                newItem.Value = int(float64(newItem.Value) * (1.0 + float64(l.FloorNumber-1)*0.1))
                        }</span>
                case item.ItemAmulet:<span class="cov0" title="0">
                        if l.FloorNumber &gt;= 20 </span><span class="cov0" title="0">{ // 深い階層でのみ魔除けを生成
                                newItem = item.NewAmulet(x, y)
                        }</span> else<span class="cov0" title="0"> {
                                continue</span> // 深い階層でない場合は別のアイテムを試す
                        }
                default:<span class="cov0" title="0">
                        newItem = l.createRandomItem(x, y, itemType)
                        // 階層に応じてアイテムの価値を調整
                        if newItem != nil </span><span class="cov0" title="0">{
                                newItem.Value = int(float64(newItem.Value) * (1.0 + float64(l.FloorNumber-1)*0.05))
                        }</span>
                }

                <span class="cov0" title="0">if newItem != nil </span><span class="cov0" title="0">{
                        l.Items = append(l.Items, newItem)
                        logger.Debug("Spawned item",
                                "type", newItem.Name,
                                "x", x,
                                "y", y,
                                "floor", l.FloorNumber,
                        )
                }</span>
                <span class="cov0" title="0">break</span>
        }
}

// selectItemType selects an item type based on the floor level
func (l *Level) selectItemType() item.ItemType <span class="cov0" title="0">{
        // 階層に応じたアイテム選択
        switch </span>{
        case l.FloorNumber &lt;= 5:<span class="cov0" title="0">
                // 浅い階層: 基本的なアイテム
                items := []item.ItemType{item.ItemGold, item.ItemFood, item.ItemPotion}
                return items[rand.Intn(len(items))]</span>
        case l.FloorNumber &lt;= 10:<span class="cov0" title="0">
                // 中間階層: より多様なアイテム
                items := []item.ItemType{item.ItemGold, item.ItemFood, item.ItemPotion, item.ItemScroll, item.ItemWeapon}
                return items[rand.Intn(len(items))]</span>
        case l.FloorNumber &lt;= 15:<span class="cov0" title="0">
                // 深い階層: 高価なアイテム
                items := []item.ItemType{item.ItemGold, item.ItemWeapon, item.ItemArmor, item.ItemRing, item.ItemScroll}
                return items[rand.Intn(len(items))]</span>
        default:<span class="cov0" title="0">
                // 最深階層: 最高のアイテム
                items := []item.ItemType{item.ItemGold, item.ItemWeapon, item.ItemArmor, item.ItemRing, item.ItemAmulet}
                return items[rand.Intn(len(items))]</span>
        }
}

// createRandomItem creates a random item of the specified type
func (l *Level) createRandomItem(x, y int, itemType item.ItemType) *item.Item <span class="cov0" title="0">{
        switch itemType </span>{
        case item.ItemWeapon:<span class="cov0" title="0">
                weapons := []string{"短剣", "剣", "メイス", "斧", "弓"}
                name := weapons[rand.Intn(len(weapons))]
                value := 10 + rand.Intn(50)
                return item.NewItem(x, y, itemType, name, value)</span>
        case item.ItemArmor:<span class="cov0" title="0">
                armors := []string{"革鎧", "鎖帷子", "板金鎧", "ローブ", "盾"}
                name := armors[rand.Intn(len(armors))]
                value := 20 + rand.Intn(80)
                return item.NewItem(x, y, itemType, name, value)</span>
        case item.ItemRing:<span class="cov0" title="0">
                rings := []string{"力の指輪", "知恵の指輪", "体力の指輪", "敏捷の指輪"}
                name := rings[rand.Intn(len(rings))]
                value := 50 + rand.Intn(100)
                return item.NewItem(x, y, itemType, name, value)</span>
        case item.ItemScroll:<span class="cov0" title="0">
                scrolls := []string{"テレポートの巻物", "識別の巻物", "治療の巻物", "魔法の巻物"}
                name := scrolls[rand.Intn(len(scrolls))]
                value := 15 + rand.Intn(35)
                return item.NewItem(x, y, itemType, name, value)</span>
        case item.ItemPotion:<span class="cov0" title="0">
                potions := []string{"体力回復薬", "魔力回復薬", "力強化薬", "敏捷強化薬"}
                name := potions[rand.Intn(len(potions))]
                value := 10 + rand.Intn(30)
                return item.NewItem(x, y, itemType, name, value)</span>
        case item.ItemFood:<span class="cov0" title="0">
                foods := []string{"パン", "肉", "果物", "チーズ", "干し肉"}
                name := foods[rand.Intn(len(foods))]
                value := 5 + rand.Intn(15)
                return item.NewItem(x, y, itemType, name, value)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// IsValidItemPosition checks if an item can be placed at the given position
func (l *Level) IsValidItemPosition(x, y int) bool <span class="cov0" title="0">{
        // 境界チェック
        if !l.IsInBounds(x, y) </span><span class="cov0" title="0">{
                return false
        }</span>

        // 歩行可能タイルかチェック
        <span class="cov0" title="0">tile := l.GetTile(x, y)
        if tile == nil || !tile.Walkable() </span><span class="cov0" title="0">{
                return false
        }</span>

        // 既にアイテムがある位置かチェック
        <span class="cov0" title="0">for _, existingItem := range l.Items </span><span class="cov0" title="0">{
                if existingItem.Position.X == x &amp;&amp; existingItem.Position.Y == y </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// GetItemAt returns the item at the given coordinates
func (l *Level) GetItemAt(x, y int) *item.Item <span class="cov0" title="0">{
        for _, item := range l.Items </span><span class="cov0" title="0">{
                if item.Position.X == x &amp;&amp; item.Position.Y == y </span><span class="cov0" title="0">{
                        return item
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemoveItem removes an item from the level
func (l *Level) RemoveItem(item *item.Item) <span class="cov0" title="0">{
        for i, it := range l.Items </span><span class="cov0" title="0">{
                if it == item </span><span class="cov0" title="0">{
                        l.Items = append(l.Items[:i], l.Items[i+1:]...)
                        logger.Debug("Removed item",
                                "type", item.Name,
                                "x", item.Position.X,
                                "y", item.Position.Y,
                        )
                        break</span>
                }
        }
}

// AddItem アイテムを指定位置に追加
func (l *Level) AddItem(item *item.Item, x, y int) <span class="cov0" title="0">{
        item.Position.X = x
        item.Position.Y = y
        l.Items = append(l.Items, item)
        logger.Debug("Item added to level",
                "type", item.Name,
                "x", x,
                "y", y,
        )
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package dungeon

import "github.com/anaseto/gruid"

// TileType represents different types of tiles in the dungeon
type TileType int

const (
        TileWall TileType = iota
        TileFloor
        TileDoorClosed
        TileDoorOpen
        TileStairsUp
        TileStairsDown
        TileWater
        TileLava
        TileSecretDoor
)

// String returns the string representation of a TileType
func (t TileType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case TileFloor:<span class="cov0" title="0">
                return "floor"</span>
        case TileWall:<span class="cov0" title="0">
                return "wall"</span>
        case TileWater:<span class="cov0" title="0">
                return "water"</span>
        case TileLava:<span class="cov0" title="0">
                return "lava"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Tile represents a single tile in the dungeon
type Tile struct {
        Type       TileType
        Rune       rune
        Color      gruid.Color
        Visible    bool
        IsWalkable bool
}

// Walkable returns whether the tile can be walked on
func (t *Tile) Walkable() bool <span class="cov0" title="0">{
        return t.IsWalkable
}</span>

// NewTile creates a new tile of the given type
func NewTile(tileType TileType) *Tile <span class="cov0" title="0">{
        t := &amp;Tile{
                Type:       tileType,
                Visible:    true, // すべてのタイルを可視化（簡素化のため）
                IsWalkable: IsWalkable(tileType),
        }
        switch tileType </span>{
        case TileWall:<span class="cov0" title="0">
                t.Rune = '#'
                t.Color = 0x826E32</span> // RGB(130, 110, 50) - PyRogue仕様
        case TileFloor:<span class="cov0" title="0">
                t.Rune = '.'
                t.Color = 0x808080</span> // Gray - PyRogue風
        case TileDoorClosed:<span class="cov0" title="0">
                t.Rune = '+'
                t.Color = 0x8B4513</span> // Brown - PyRogue風
        case TileDoorOpen:<span class="cov0" title="0">
                t.Rune = '/'
                t.Color = 0x8B4513</span> // Brown - PyRogue風
        case TileStairsUp:<span class="cov0" title="0">
                t.Rune = '&lt;'
                t.Color = 0xFFFFFF</span> // White - PyRogue風
        case TileStairsDown:<span class="cov0" title="0">
                t.Rune = '&gt;'
                t.Color = 0xFFFFFF</span> // White - PyRogue風
        case TileWater:<span class="cov0" title="0">
                t.Rune = '~'
                t.Color = 0x00FFFF</span> // Cyan - PyRogue風
        case TileLava:<span class="cov0" title="0">
                t.Rune = '^'
                t.Color = 0xFF0000</span> // Red - PyRogue風
        case TileSecretDoor:<span class="cov0" title="0">
                t.Rune = '#'
                t.Color = 0x826E32</span> // RGB(130, 110, 50) - PyRogue仕様
        default:<span class="cov0" title="0">
                t.Rune = ' '</span>
        }
        <span class="cov0" title="0">return t</span>
}

// IsWalkable returns whether the tile can be walked on
func IsWalkable(t TileType) bool <span class="cov0" title="0">{
        switch t </span>{
        case TileFloor, TileDoorOpen, TileStairsUp, TileStairsDown:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package identification

import (
        "fmt"
        "math/rand"

        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// IdentificationManager manages item identification state
type IdentificationManager struct {
        // Global identification state for each item type
        identifiedScrolls map[string]bool
        identifiedPotions map[string]bool
        identifiedRings   map[string]bool
        identifiedWands   map[string]bool

        // Random appearances for unidentified items
        scrollTitles  map[string]string
        potionColors  map[string]string
        ringMaterials map[string]string
        wandMaterials map[string]string
}

// ScrollTitles are random titles for unidentified scrolls
var ScrollTitles = []string{
        "ZELGO MER", "JUYED AWK YACC", "NR 9", "XIXAXA XOXAXA XUXAXA",
        "PRATYAVAYAH", "DAIYEN FOOELS", "LEP GEX VEN ZEA", "PRIRUTSENIE",
        "ELBIB YLOH", "VERR YED HORRE", "VENZAR BORGAVVE", "THARR",
        "YUM YUM", "KERNOD WEL", "ELAM EBOW", "DUAM XNAHT", "ANDOVA BEGARIN",
        "KIRJE", "VE FORBRYDERNE", "CHATCHE", "VELOX NEB", "FOOBIE BLETCH",
        "TEMOV", "GARVEN DEH",
}

// PotionColors are random colors for unidentified potions
var PotionColors = []string{
        "red", "blue", "green", "yellow", "black", "brown", "orange", "pink",
        "purple", "white", "clear", "grey", "dark", "light blue", "magenta",
        "amber", "bubbly", "cloudy", "dark green", "dark blue", "emerald",
        "fizzy", "glowing", "golden", "icy", "luminescent", "metallic",
        "milky", "murky", "oily", "puce", "ruby", "silver", "smoky",
        "swirling", "viscous", "ecru", "ochre",
}

// RingMaterials are random materials for unidentified rings
var RingMaterials = []string{
        "wooden", "granite", "opal", "clay", "coral", "black onyx", "moonstone",
        "tiger eye", "jade", "bronze", "agate", "topaz", "sapphire", "ruby",
        "diamond", "pearl", "iron", "brass", "copper", "twisted", "steel",
        "silver", "gold", "ivory", "emerald", "wire", "engagement", "shining",
        "fluorite", "obsidian", "agate", "plastic",
}

// WandMaterials are random materials for unidentified wands
var WandMaterials = []string{
        "glass", "balsa", "crystal", "maple", "pine", "oak", "ebony", "marble",
        "silver", "runed", "long", "short", "bent", "curvy", "twisted", "forked",
        "spiked", "jeweled", "black", "octagonal", "mahogany", "walnut",
}

// NewIdentificationManager creates a new identification manager
func NewIdentificationManager() *IdentificationManager <span class="cov0" title="0">{
        mgr := &amp;IdentificationManager{
                identifiedScrolls: make(map[string]bool),
                identifiedPotions: make(map[string]bool),
                identifiedRings:   make(map[string]bool),
                identifiedWands:   make(map[string]bool),
                scrollTitles:      make(map[string]string),
                potionColors:      make(map[string]string),
                ringMaterials:     make(map[string]string),
                wandMaterials:     make(map[string]string),
        }

        // Initialize random appearances
        mgr.initializeAppearances()

        return mgr
}</span>

// initializeAppearances sets up random appearances for items
func (im *IdentificationManager) initializeAppearances() <span class="cov0" title="0">{
        // Assign random scroll titles
        scrollNames := []string{
                "identify", "teleportation", "sleep", "enchant armor", "enchant weapon",
                "create monster", "remove curse", "aggravate monster", "magic mapping",
                "hold monster", "confuse monster", "scare monster", "blank paper",
                "genocide", "light", "food detection", "gold detection", "potion detection",
                "magic detection", "monster detection", "trap detection", "strength",
                "hit point maximum increase", "monster confusion", "destroy armor",
                "fire", "ice", "charging", "polymorph", "fake",
        }

        shuffledTitles := make([]string, len(ScrollTitles))
        copy(shuffledTitles, ScrollTitles)
        rand.Shuffle(len(shuffledTitles), func(i, j int) </span><span class="cov0" title="0">{
                shuffledTitles[i], shuffledTitles[j] = shuffledTitles[j], shuffledTitles[i]
        }</span>)

        <span class="cov0" title="0">for i, name := range scrollNames </span><span class="cov0" title="0">{
                if i &lt; len(shuffledTitles) </span><span class="cov0" title="0">{
                        im.scrollTitles[name] = shuffledTitles[i]
                }</span>
        }

        // Assign random potion colors
        <span class="cov0" title="0">potionNames := []string{
                "healing", "extra healing", "haste self", "restore strength", "blindness",
                "paralysis", "confusion", "hallucination", "poison", "gain strength",
                "see invisible", "gain experience", "thirst quenching", "magic detection",
                "monster detection", "object detection", "raise level", "gain dexterity",
                "gain constitution", "gain intelligence", "gain wisdom", "gain charisma",
                "cure disease", "speed", "levitation", "invisibility",
        }

        shuffledColors := make([]string, len(PotionColors))
        copy(shuffledColors, PotionColors)
        rand.Shuffle(len(shuffledColors), func(i, j int) </span><span class="cov0" title="0">{
                shuffledColors[i], shuffledColors[j] = shuffledColors[j], shuffledColors[i]
        }</span>)

        <span class="cov0" title="0">for i, name := range potionNames </span><span class="cov0" title="0">{
                if i &lt; len(shuffledColors) </span><span class="cov0" title="0">{
                        im.potionColors[name] = shuffledColors[i]
                }</span>
        }

        // Assign random ring materials
        <span class="cov0" title="0">ringNames := []string{
                "protection", "add strength", "sustain strength", "searching", "see invisible",
                "adornment", "teleportation", "stealth", "regeneration", "slow digestion",
                "dexterity", "increase damage", "protection from magic", "hunger",
                "aggravate monster", "maintain armor", "teleport control",
        }

        shuffledMaterials := make([]string, len(RingMaterials))
        copy(shuffledMaterials, RingMaterials)
        rand.Shuffle(len(shuffledMaterials), func(i, j int) </span><span class="cov0" title="0">{
                shuffledMaterials[i], shuffledMaterials[j] = shuffledMaterials[j], shuffledMaterials[i]
        }</span>)

        <span class="cov0" title="0">for i, name := range ringNames </span><span class="cov0" title="0">{
                if i &lt; len(shuffledMaterials) </span><span class="cov0" title="0">{
                        im.ringMaterials[name] = shuffledMaterials[i]
                }</span>
        }

        <span class="cov0" title="0">logger.Debug("Initialized item appearances for identification system")</span>
}

// GetDisplayName returns the display name for an item (identified or unidentified)
func (im *IdentificationManager) GetDisplayName(itm *item.Item) string <span class="cov0" title="0">{
        switch itm.Type </span>{
        case item.ItemScroll:<span class="cov0" title="0">
                if im.IsIdentified(itm) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("scroll of %s", itm.Name)
                }</span>
                <span class="cov0" title="0">if title, exists := im.scrollTitles[itm.Name]; exists </span><span class="cov0" title="0">{
                        return fmt.Sprintf("scroll titled %q", title)
                }</span>
                <span class="cov0" title="0">return "scroll titled \"UNKNOWN\""</span>

        case item.ItemPotion:<span class="cov0" title="0">
                if im.IsIdentified(itm) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("potion of %s", itm.Name)
                }</span>
                <span class="cov0" title="0">if color, exists := im.potionColors[itm.Name]; exists </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s potion", color)
                }</span>
                <span class="cov0" title="0">return "unknown potion"</span>

        case item.ItemRing:<span class="cov0" title="0">
                if im.IsIdentified(itm) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("ring of %s", itm.Name)
                }</span>
                <span class="cov0" title="0">if material, exists := im.ringMaterials[itm.Name]; exists </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s ring", material)
                }</span>
                <span class="cov0" title="0">return "unknown ring"</span>

        case item.ItemWeapon:<span class="cov0" title="0">
                // Weapons are usually identified
                return itm.Name</span>

        case item.ItemArmor:<span class="cov0" title="0">
                // Armor is usually identified
                return itm.Name</span>

        case item.ItemFood:<span class="cov0" title="0">
                // Food is usually identified
                return itm.Name</span>

        case item.ItemGold:<span class="cov0" title="0">
                // Gold is always identified
                return fmt.Sprintf("%d gold pieces", itm.Value)</span>

        case item.ItemAmulet:<span class="cov0" title="0">
                // The Amulet of Yendor is always identified
                return itm.Name</span>

        default:<span class="cov0" title="0">
                return itm.Name</span>
        }
}

// IsIdentified checks if an item type is identified
func (im *IdentificationManager) IsIdentified(itm *item.Item) bool <span class="cov0" title="0">{
        switch itm.Type </span>{
        case item.ItemScroll:<span class="cov0" title="0">
                return im.identifiedScrolls[itm.Name]</span>
        case item.ItemPotion:<span class="cov0" title="0">
                return im.identifiedPotions[itm.Name]</span>
        case item.ItemRing:<span class="cov0" title="0">
                return im.identifiedRings[itm.Name]</span>
        case item.ItemWeapon, item.ItemArmor, item.ItemFood, item.ItemGold, item.ItemAmulet:<span class="cov0" title="0">
                // These are always identified
                return true</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// IdentifyItem identifies an item type globally
func (im *IdentificationManager) IdentifyItem(itm *item.Item) <span class="cov0" title="0">{
        switch itm.Type </span>{
        case item.ItemScroll:<span class="cov0" title="0">
                im.identifiedScrolls[itm.Name] = true
                logger.Debug("Identified scroll", "name", itm.Name)</span>
        case item.ItemPotion:<span class="cov0" title="0">
                im.identifiedPotions[itm.Name] = true
                logger.Debug("Identified potion", "name", itm.Name)</span>
        case item.ItemRing:<span class="cov0" title="0">
                im.identifiedRings[itm.Name] = true
                logger.Debug("Identified ring", "name", itm.Name)</span>
        }
}

// IdentifyByUse identifies an item when used
func (im *IdentificationManager) IdentifyByUse(itm *item.Item) <span class="cov0" title="0">{
        if !im.IsIdentified(itm) </span><span class="cov0" title="0">{
                im.IdentifyItem(itm)
                logger.Info("Item identified by use", "item", itm.Name, "type", itm.Type)
        }</span>
}

// GetIdentificationScroll creates a scroll of identify
func (im *IdentificationManager) GetIdentificationScroll() *item.Item <span class="cov0" title="0">{
        return item.NewItem(0, 0, item.ItemScroll, "identify", 100)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package inventory

import (
        "fmt"

        "github.com/yuru-sha/gorogue/internal/game/identification"
        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

const (
        MaxInventorySize = 26 // PyRogue互換：A-Zの26個
)

// Inventory represents a player's inventory
type Inventory struct {
        Items    []*item.Item
        Capacity int
}

// Equipment represents equipped items
type Equipment struct {
        Weapon    *item.Item
        Armor     *item.Item
        RingLeft  *item.Item
        RingRight *item.Item
}

// NewInventory creates a new inventory
func NewInventory() *Inventory <span class="cov8" title="1">{
        return &amp;Inventory{
                Items:    make([]*item.Item, 0, MaxInventorySize),
                Capacity: MaxInventorySize,
        }
}</span>

// NewEquipment creates a new equipment set
func NewEquipment() *Equipment <span class="cov8" title="1">{
        return &amp;Equipment{}
}</span>

// AddItem adds an item to the inventory
func (inv *Inventory) AddItem(newItem *item.Item) bool <span class="cov8" title="1">{
        if len(inv.Items) &gt;= inv.Capacity </span><span class="cov8" title="1">{
                logger.Debug("Inventory full", "capacity", inv.Capacity)
                return false
        }</span>

        // Check if item can stack (for gold, food, etc.)
        <span class="cov8" title="1">if newItem.Type == item.ItemGold </span><span class="cov0" title="0">{
                // Try to stack with existing gold
                for _, existingItem := range inv.Items </span><span class="cov0" title="0">{
                        if existingItem.Type == item.ItemGold </span><span class="cov0" title="0">{
                                existingItem.Value += newItem.Value
                                existingItem.Quantity += newItem.Quantity
                                logger.Debug("Stacked gold",
                                        "total_value", existingItem.Value,
                                        "total_quantity", existingItem.Quantity,
                                )
                                return true
                        }</span>
                }
        }

        // Add as new item
        <span class="cov8" title="1">inv.Items = append(inv.Items, newItem)
        logger.Debug("Added item to inventory",
                "item", newItem.Name,
                "type", newItem.Type,
                "inventory_size", len(inv.Items),
        )
        return true</span>
}

// RemoveItem removes an item from the inventory
func (inv *Inventory) RemoveItem(index int) *item.Item <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(inv.Items) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">removedItem := inv.Items[index]
        inv.Items = append(inv.Items[:index], inv.Items[index+1:]...)

        logger.Debug("Removed item from inventory",
                "item", removedItem.Name,
                "inventory_size", len(inv.Items),
        )
        return removedItem</span>
}

// GetItem returns an item by index
func (inv *Inventory) GetItem(index int) *item.Item <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(inv.Items) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return inv.Items[index]</span>
}

// GetItemByLetter returns an item by letter (a-z)
func (inv *Inventory) GetItemByLetter(letter rune) (int, *item.Item) <span class="cov0" title="0">{
        if letter &lt; 'a' || letter &gt; 'z' </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov0" title="0">index := int(letter - 'a')
        if index &gt;= len(inv.Items) </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov0" title="0">return index, inv.Items[index]</span>
}

// IsFull checks if the inventory is full
func (inv *Inventory) IsFull() bool <span class="cov8" title="1">{
        return len(inv.Items) &gt;= inv.Capacity
}</span>

// IsEmpty checks if the inventory is empty
func (inv *Inventory) IsEmpty() bool <span class="cov8" title="1">{
        return len(inv.Items) == 0
}</span>

// Size returns the current inventory size
func (inv *Inventory) Size() int <span class="cov0" title="0">{
        return len(inv.Items)
}</span>

// GetInventoryListing returns a formatted inventory listing
func (inv *Inventory) GetInventoryListing(identifyMgr *identification.IdentificationManager) []string <span class="cov8" title="1">{
        if inv.IsEmpty() </span><span class="cov8" title="1">{
                return []string{"Your pack is empty."}
        }</span>

        <span class="cov8" title="1">listing := make([]string, 0, len(inv.Items)+1)
        listing = append(listing, "Current inventory:")

        for i, itm := range inv.Items </span><span class="cov8" title="1">{
                letter := rune('a' + i)
                var line string

                // 識別マネージャーを使用して表示名を取得
                if identifyMgr != nil </span><span class="cov0" title="0">{
                        displayName := identifyMgr.GetDisplayName(itm)
                        line = fmt.Sprintf("%c) %s", letter, displayName)
                }</span> else<span class="cov8" title="1"> {
                        // フォールバック：識別マネージャーがない場合
                        if itm.Type == item.ItemGold </span><span class="cov0" title="0">{
                                line = fmt.Sprintf("%c) %d gold pieces", letter, itm.Value)
                        }</span> else<span class="cov8" title="1"> {
                                line = fmt.Sprintf("%c) %s", letter, itm.Name)
                        }</span>
                }

                <span class="cov8" title="1">listing = append(listing, line)</span>
        }

        <span class="cov8" title="1">return listing</span>
}

// EquipItem equips an item from inventory
func (eq *Equipment) EquipItem(itm *item.Item) bool <span class="cov8" title="1">{
        switch itm.Type </span>{
        case item.ItemWeapon:<span class="cov8" title="1">
                eq.Weapon = itm
                logger.Debug("Equipped weapon", "weapon", itm.Name)
                return true</span>
        case item.ItemArmor:<span class="cov8" title="1">
                eq.Armor = itm
                logger.Debug("Equipped armor", "armor", itm.Name)
                return true</span>
        case item.ItemRing:<span class="cov8" title="1">
                if eq.RingLeft == nil </span><span class="cov8" title="1">{
                        eq.RingLeft = itm
                        logger.Debug("Equipped ring on left hand", "ring", itm.Name)
                        return true
                }</span> else<span class="cov0" title="0"> if eq.RingRight == nil </span><span class="cov0" title="0">{
                        eq.RingRight = itm
                        logger.Debug("Equipped ring on right hand", "ring", itm.Name)
                        return true
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug("Both ring slots occupied")
                        return false
                }</span>
        default:<span class="cov8" title="1">
                logger.Debug("Item cannot be equipped", "item", itm.Name, "type", itm.Type)
                return false</span>
        }
}

// UnequipItem unequips an item by slot
func (eq *Equipment) UnequipItem(slot string) *item.Item <span class="cov8" title="1">{
        switch slot </span>{
        case "weapon":<span class="cov8" title="1">
                if eq.Weapon != nil </span><span class="cov8" title="1">{
                        item := eq.Weapon
                        eq.Weapon = nil
                        logger.Debug("Unequipped weapon", "weapon", item.Name)
                        return item
                }</span>
        case "armor":<span class="cov0" title="0">
                if eq.Armor != nil </span><span class="cov0" title="0">{
                        item := eq.Armor
                        eq.Armor = nil
                        logger.Debug("Unequipped armor", "armor", item.Name)
                        return item
                }</span>
        case "ring_left":<span class="cov0" title="0">
                if eq.RingLeft != nil </span><span class="cov0" title="0">{
                        item := eq.RingLeft
                        eq.RingLeft = nil
                        logger.Debug("Unequipped left ring", "ring", item.Name)
                        return item
                }</span>
        case "ring_right":<span class="cov0" title="0">
                if eq.RingRight != nil </span><span class="cov0" title="0">{
                        item := eq.RingRight
                        eq.RingRight = nil
                        logger.Debug("Unequipped right ring", "ring", item.Name)
                        return item
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

const noneEquipped = "None"

// GetEquippedNames returns equipped item names for display
func (eq *Equipment) GetEquippedNames() (string, string, string, string) <span class="cov8" title="1">{
        weapon := noneEquipped
        armor := noneEquipped
        ringLeft := noneEquipped
        ringRight := noneEquipped

        if eq.Weapon != nil </span><span class="cov8" title="1">{
                weapon = eq.Weapon.Name
        }</span>
        <span class="cov8" title="1">if eq.Armor != nil </span><span class="cov8" title="1">{
                armor = eq.Armor.Name
        }</span>
        <span class="cov8" title="1">if eq.RingLeft != nil </span><span class="cov0" title="0">{
                ringLeft = eq.RingLeft.Name
        }</span>
        <span class="cov8" title="1">if eq.RingRight != nil </span><span class="cov0" title="0">{
                ringRight = eq.RingRight.Name
        }</span>

        <span class="cov8" title="1">return weapon, armor, ringLeft, ringRight</span>
}

// GetAttackBonus returns attack bonus from equipped weapon
func (eq *Equipment) GetAttackBonus() int <span class="cov8" title="1">{
        if eq.Weapon != nil </span><span class="cov8" title="1">{
                return eq.Weapon.Value / 10 // Simple calculation
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// GetDefenseBonus returns defense bonus from equipped armor
func (eq *Equipment) GetDefenseBonus() int <span class="cov8" title="1">{
        bonus := 0
        if eq.Armor != nil </span><span class="cov8" title="1">{
                bonus += eq.Armor.Value / 10
        }</span>
        <span class="cov8" title="1">if eq.RingLeft != nil &amp;&amp; eq.RingLeft.Type == item.ItemRing </span><span class="cov0" title="0">{
                bonus += eq.RingLeft.Value / 20
        }</span>
        <span class="cov8" title="1">if eq.RingRight != nil &amp;&amp; eq.RingRight.Type == item.ItemRing </span><span class="cov0" title="0">{
                bonus += eq.RingRight.Value / 20
        }</span>
        <span class="cov8" title="1">return bonus</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package item

import (
        "math/rand"

        "github.com/anaseto/gruid"
        "github.com/yuru-sha/gorogue/internal/core/entity"
)

// ItemType represents different types of items
type ItemType int

const (
        ItemWeapon ItemType = iota
        ItemArmor
        ItemRing
        ItemScroll
        ItemPotion
        ItemFood
        ItemGold
        ItemAmulet // イェンダーの魔除け
)

// Item represents an item in the game
type Item struct {
        *entity.Entity
        Type         ItemType
        Name         string
        RealName     string // 真の名前（識別前後で同じ）
        Value        int    // ゴールドとしての価値
        Quantity     int
        IsIdentified bool // このアイテムが識別済みかどうか
        IsCursed     bool // 呪われているかどうか
        IsBlessed    bool // 祝福されているかどうか
}

// GetItemSymbol returns the symbol for a given item type
func GetItemSymbol(t ItemType) rune <span class="cov0" title="0">{
        switch t </span>{
        case ItemWeapon:<span class="cov0" title="0">
                return ')'</span>
        case ItemArmor:<span class="cov0" title="0">
                return '['</span>
        case ItemRing:<span class="cov0" title="0">
                return '='</span>
        case ItemScroll:<span class="cov0" title="0">
                return '?'</span>
        case ItemPotion:<span class="cov0" title="0">
                return '!'</span>
        case ItemFood:<span class="cov0" title="0">
                return '%'</span>
        case ItemGold:<span class="cov0" title="0">
                return '$'</span>

        case ItemAmulet:<span class="cov0" title="0">
                return '&amp;'</span>
        default:<span class="cov0" title="0">
                return '*'</span>
        }
}

// GetItemColor returns the color for a given item type - PyRogue風
func GetItemColor(t ItemType) gruid.Color <span class="cov0" title="0">{
        switch t </span>{
        case ItemWeapon:<span class="cov0" title="0">
                return 0xC0C0C0</span> // Silver - PyRogue風
        case ItemArmor:<span class="cov0" title="0">
                return 0x8B4513</span> // Brown - PyRogue風
        case ItemRing:<span class="cov0" title="0">
                return 0xFFD700</span> // Gold - PyRogue風
        case ItemScroll:<span class="cov0" title="0">
                return 0xFFFFFF</span> // White - PyRogue風
        case ItemPotion:<span class="cov0" title="0">
                return 0xFF1493</span> // DeepPink - PyRogue風
        case ItemFood:<span class="cov0" title="0">
                return 0xFFA500</span> // Orange - PyRogue風
        case ItemGold:<span class="cov0" title="0">
                return 0xFFD700</span> // Gold - PyRogue風
        case ItemAmulet:<span class="cov0" title="0">
                return 0x9400D3</span> // Purple - PyRogue風（特別なアイテム）
        default:<span class="cov0" title="0">
                return 0xDA70D6</span> // Orchid - PyRogue風（デフォルト紫系）
        }
}

// NewItem creates a new item
func NewItem(x, y int, itemType ItemType, name string, value int) *Item <span class="cov0" title="0">{
        // Determine if item should start identified
        isIdentified := true
        switch itemType </span>{
        case ItemScroll, ItemPotion, ItemRing:<span class="cov0" title="0">
                isIdentified = false</span> // These need to be identified
        }

        <span class="cov0" title="0">return &amp;Item{
                Entity:       entity.NewEntity(x, y, GetItemSymbol(itemType), GetItemColor(itemType)),
                Type:         itemType,
                Name:         name,
                RealName:     name,
                Value:        value,
                Quantity:     1,
                IsIdentified: isIdentified,
                IsCursed:     false,
                IsBlessed:    false,
        }</span>
}

// NewGold creates a new gold pile with random amount
func NewGold(x, y int, isSpecialRoom bool) *Item <span class="cov0" title="0">{
        var amount int
        if isSpecialRoom </span><span class="cov0" title="0">{
                amount = 100 + rand.Intn(151) // 100-250
        }</span> else<span class="cov0" title="0"> {
                amount = 1 + rand.Intn(250) // 1-250
        }</span>
        <span class="cov0" title="0">return NewItem(x, y, ItemGold, "Gold", amount)</span>
}

// NewAmulet creates Yendor's amulet
func NewAmulet(x, y int) *Item <span class="cov0" title="0">{
        return NewItem(x, y, ItemAmulet, "イェンダーの魔除け", 1000)
}</span>

// NewRandomScroll creates a random scroll
func NewRandomScroll(x, y int) *Item <span class="cov0" title="0">{
        scrollTypes := []string{
                "identify", "teleportation", "sleep", "enchant armor", "enchant weapon",
                "create monster", "remove curse", "aggravate monster", "magic mapping",
                "hold monster", "confuse monster", "scare monster", "blank paper",
                "light", "food detection", "gold detection", "potion detection",
                "magic detection", "monster detection", "trap detection",
        }

        scrollType := scrollTypes[rand.Intn(len(scrollTypes))]
        return NewItem(x, y, ItemScroll, scrollType, 50+rand.Intn(100))
}</span>

// NewRandomPotion creates a random potion
func NewRandomPotion(x, y int) *Item <span class="cov0" title="0">{
        potionTypes := []string{
                "healing", "extra healing", "haste self", "restore strength", "blindness",
                "paralysis", "confusion", "hallucination", "poison", "gain strength",
                "see invisible", "gain experience", "thirst quenching", "magic detection",
                "monster detection", "object detection", "raise level", "gain dexterity",
                "gain constitution", "gain intelligence", "levitation", "invisibility",
        }

        potionType := potionTypes[rand.Intn(len(potionTypes))]
        return NewItem(x, y, ItemPotion, potionType, 25+rand.Intn(75))
}</span>

// NewRandomRing creates a random ring
func NewRandomRing(x, y int) *Item <span class="cov0" title="0">{
        ringTypes := []string{
                "protection", "add strength", "sustain strength", "searching", "see invisible",
                "adornment", "teleportation", "stealth", "regeneration", "slow digestion",
                "dexterity", "increase damage", "protection from magic", "hunger",
                "aggravate monster", "maintain armor", "teleport control",
        }

        ringType := ringTypes[rand.Intn(len(ringTypes))]
        return NewItem(x, y, ItemRing, ringType, 100+rand.Intn(200))
}</span>

// NewFood creates food item
func NewFood(x, y int) *Item <span class="cov0" title="0">{
        foodTypes := []string{"food ration", "slime-mold", "fruit"}
        foodType := foodTypes[rand.Intn(len(foodTypes))]
        return NewItem(x, y, ItemFood, foodType, 10+rand.Intn(20))
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package magic

import (
        "fmt"
        "math/rand"

        "github.com/yuru-sha/gorogue/internal/game/actor"
        "github.com/yuru-sha/gorogue/internal/game/dungeon"
        "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// EffectResult represents the result of using a magic item
type EffectResult struct {
        Message    string
        Success    bool
        Identified bool // Whether the item should be identified after use
}

// UseScroll applies the effect of a scroll
func UseScroll(scrollName string, player *actor.Player, level *dungeon.Level) *EffectResult <span class="cov0" title="0">{
        switch scrollName </span>{
        case "identify":<span class="cov0" title="0">
                return useScrollOfIdentify(player)</span>
        case "teleportation":<span class="cov0" title="0">
                return useScrollOfTeleportation(player, level)</span>
        case "sleep":<span class="cov0" title="0">
                return useScrollOfSleep(level)</span>
        case "enchant armor":<span class="cov0" title="0">
                return useScrollOfEnchantArmor(player)</span>
        case "enchant weapon":<span class="cov0" title="0">
                return useScrollOfEnchantWeapon(player)</span>
        case "remove curse":<span class="cov0" title="0">
                return useScrollOfRemoveCurse(player)</span>
        case "magic mapping":<span class="cov0" title="0">
                return useScrollOfMagicMapping(level)</span>
        case "light":<span class="cov0" title="0">
                return useScrollOfLight(level)</span>
        case "food detection":<span class="cov0" title="0">
                return useScrollOfDetection(level, "food")</span>
        case "gold detection":<span class="cov0" title="0">
                return useScrollOfDetection(level, "gold")</span>
        case "potion detection":<span class="cov0" title="0">
                return useScrollOfDetection(level, "potion")</span>
        case "monster detection":<span class="cov0" title="0">
                return useScrollOfDetection(level, "monster")</span>
        case "blank paper":<span class="cov0" title="0">
                return &amp;EffectResult{
                        Message:    "This scroll is blank.",
                        Success:    false,
                        Identified: true,
                }</span>
        default:<span class="cov0" title="0">
                return &amp;EffectResult{
                        Message:    "Nothing happens.",
                        Success:    false,
                        Identified: true,
                }</span>
        }
}

// UsePotion applies the effect of a potion
func UsePotion(potionName string, player *actor.Player) *EffectResult <span class="cov0" title="0">{
        switch potionName </span>{
        case "healing":<span class="cov0" title="0">
                return usePotionOfHealing(player, 10)</span>
        case "extra healing":<span class="cov0" title="0">
                return usePotionOfHealing(player, 20)</span>
        case "haste self":<span class="cov0" title="0">
                return usePotionOfHaste(player)</span>
        case "restore strength":<span class="cov0" title="0">
                return usePotionOfRestoreStrength(player)</span>
        case "gain strength":<span class="cov0" title="0">
                return usePotionOfGainStrength(player)</span>
        case "gain experience":<span class="cov0" title="0">
                return usePotionOfGainExperience(player)</span>
        case "see invisible":<span class="cov0" title="0">
                return usePotionOfSeeInvisible(player)</span>
        case "blindness":<span class="cov0" title="0">
                return usePotionOfBlindness(player)</span>
        case "paralysis":<span class="cov0" title="0">
                return usePotionOfParalysis(player)</span>
        case "confusion":<span class="cov0" title="0">
                return usePotionOfConfusion(player)</span>
        case "poison":<span class="cov0" title="0">
                return usePotionOfPoison(player)</span>
        case "thirst quenching":<span class="cov0" title="0">
                return &amp;EffectResult{
                        Message:    "You feel refreshed.",
                        Success:    true,
                        Identified: true,
                }</span>
        default:<span class="cov0" title="0">
                return &amp;EffectResult{
                        Message:    "Nothing happens.",
                        Success:    false,
                        Identified: true,
                }</span>
        }
}

// useScrollOfIdentify identifies an unknown item
func useScrollOfIdentify(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement item selection for identification
        return &amp;EffectResult{
                Message:    "You feel enlightened. (TODO: Select item to identify)",
                Success:    true,
                Identified: true,
        }
}</span>

// useScrollOfTeleportation teleports the player to a random location
func useScrollOfTeleportation(player *actor.Player, level *dungeon.Level) *EffectResult <span class="cov0" title="0">{
        // Find a random walkable tile
        for attempts := 0; attempts &lt; 100; attempts++ </span><span class="cov0" title="0">{
                x := rand.Intn(level.Width)
                y := rand.Intn(level.Height)

                tile := level.GetTile(x, y)
                if tile.Walkable() </span><span class="cov0" title="0">{
                        player.Position.X = x
                        player.Position.Y = y
                        logger.Debug("Player teleported", "x", x, "y", y)
                        return &amp;EffectResult{
                                Message:    "You suddenly find yourself somewhere else!",
                                Success:    true,
                                Identified: true,
                        }
                }</span>
        }

        <span class="cov0" title="0">return &amp;EffectResult{
                Message:    "The scroll crumbles to dust.",
                Success:    false,
                Identified: true,
        }</span>
}

// useScrollOfSleep puts nearby monsters to sleep
func useScrollOfSleep(level *dungeon.Level) *EffectResult <span class="cov0" title="0">{
        sleepCount := 0
        for _, monster := range level.Monsters </span><span class="cov0" title="0">{
                if monster.IsAlive() </span><span class="cov0" title="0">{
                        // Simple sleep effect - monsters skip next few turns
                        sleepCount++
                }</span>
        }

        <span class="cov0" title="0">if sleepCount &gt; 0 </span><span class="cov0" title="0">{
                return &amp;EffectResult{
                        Message:    fmt.Sprintf("You hear %d monster(s) yawn.", sleepCount),
                        Success:    true,
                        Identified: true,
                }
        }</span>

        <span class="cov0" title="0">return &amp;EffectResult{
                Message:    "You hear a faint snoring sound.",
                Success:    true,
                Identified: true,
        }</span>
}

// useScrollOfEnchantArmor enhances equipped armor
func useScrollOfEnchantArmor(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        if player.Equipment.Armor != nil </span><span class="cov0" title="0">{
                player.Equipment.Armor.Value += 10
                return &amp;EffectResult{
                        Message:    "Your armor glows momentarily.",
                        Success:    true,
                        Identified: true,
                }
        }</span>

        <span class="cov0" title="0">return &amp;EffectResult{
                Message:    "You are not wearing any armor.",
                Success:    false,
                Identified: true,
        }</span>
}

// useScrollOfEnchantWeapon enhances equipped weapon
func useScrollOfEnchantWeapon(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        if player.Equipment.Weapon != nil </span><span class="cov0" title="0">{
                player.Equipment.Weapon.Value += 10
                return &amp;EffectResult{
                        Message:    "Your weapon glows momentarily.",
                        Success:    true,
                        Identified: true,
                }
        }</span>

        <span class="cov0" title="0">return &amp;EffectResult{
                Message:    "You are not wielding any weapon.",
                Success:    false,
                Identified: true,
        }</span>
}

// useScrollOfRemoveCurse removes curses from items
func useScrollOfRemoveCurse(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        cursedCount := 0

        // Check equipped items
        if player.Equipment.Weapon != nil &amp;&amp; player.Equipment.Weapon.IsCursed </span><span class="cov0" title="0">{
                player.Equipment.Weapon.IsCursed = false
                cursedCount++
        }</span>
        <span class="cov0" title="0">if player.Equipment.Armor != nil &amp;&amp; player.Equipment.Armor.IsCursed </span><span class="cov0" title="0">{
                player.Equipment.Armor.IsCursed = false
                cursedCount++
        }</span>
        <span class="cov0" title="0">if player.Equipment.RingLeft != nil &amp;&amp; player.Equipment.RingLeft.IsCursed </span><span class="cov0" title="0">{
                player.Equipment.RingLeft.IsCursed = false
                cursedCount++
        }</span>
        <span class="cov0" title="0">if player.Equipment.RingRight != nil &amp;&amp; player.Equipment.RingRight.IsCursed </span><span class="cov0" title="0">{
                player.Equipment.RingRight.IsCursed = false
                cursedCount++
        }</span>

        // Check inventory items
        <span class="cov0" title="0">for _, item := range player.Inventory.Items </span><span class="cov0" title="0">{
                if item.IsCursed </span><span class="cov0" title="0">{
                        item.IsCursed = false
                        cursedCount++
                }</span>
        }

        <span class="cov0" title="0">if cursedCount &gt; 0 </span><span class="cov0" title="0">{
                return &amp;EffectResult{
                        Message:    "You feel as if someone is watching over you.",
                        Success:    true,
                        Identified: true,
                }
        }</span>

        <span class="cov0" title="0">return &amp;EffectResult{
                Message:    "You feel like someone is watching over you.",
                Success:    true,
                Identified: true,
        }</span>
}

// useScrollOfMagicMapping reveals the entire level layout
func useScrollOfMagicMapping(level *dungeon.Level) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement magic mapping effect
        return &amp;EffectResult{
                Message:    "You see the layout of the dungeon flash before your eyes.",
                Success:    true,
                Identified: true,
        }
}</span>

// useScrollOfLight illuminates the area
func useScrollOfLight(level *dungeon.Level) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement light effect
        return &amp;EffectResult{
                Message:    "The dungeon is lit up.",
                Success:    true,
                Identified: true,
        }
}</span>

// useScrollOfDetection detects specific item types
func useScrollOfDetection(level *dungeon.Level, detectType string) *EffectResult <span class="cov0" title="0">{
        count := 0

        switch detectType </span>{
        case "food":<span class="cov0" title="0">
                for _, itm := range level.Items </span><span class="cov0" title="0">{
                        if itm.Type == item.ItemFood </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        case "gold":<span class="cov0" title="0">
                for _, itm := range level.Items </span><span class="cov0" title="0">{
                        if itm.Type == item.ItemGold </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        case "potion":<span class="cov0" title="0">
                for _, itm := range level.Items </span><span class="cov0" title="0">{
                        if itm.Type == item.ItemPotion </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        case "monster":<span class="cov0" title="0">
                for _, monster := range level.Monsters </span><span class="cov0" title="0">{
                        if monster.IsAlive() </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        }

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                return &amp;EffectResult{
                        Message:    fmt.Sprintf("You sense %d %s(s) on this level.", count, detectType),
                        Success:    true,
                        Identified: true,
                }
        }</span>

        <span class="cov0" title="0">return &amp;EffectResult{
                Message:    fmt.Sprintf("You sense no %ss on this level.", detectType),
                Success:    true,
                Identified: true,
        }</span>
}

// usePotionOfHealing restores HP
func usePotionOfHealing(player *actor.Player, amount int) *EffectResult <span class="cov0" title="0">{
        oldHP := player.HP
        player.Heal(amount)
        healedAmount := player.HP - oldHP

        if healedAmount &gt; 0 </span><span class="cov0" title="0">{
                return &amp;EffectResult{
                        Message:    fmt.Sprintf("You feel better. (%d HP restored)", healedAmount),
                        Success:    true,
                        Identified: true,
                }
        }</span>

        <span class="cov0" title="0">return &amp;EffectResult{
                Message:    "Nothing happens.",
                Success:    false,
                Identified: true,
        }</span>
}

// usePotionOfHaste speeds up the player
func usePotionOfHaste(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement haste effect
        return &amp;EffectResult{
                Message:    "You feel yourself moving much faster.",
                Success:    true,
                Identified: true,
        }
}</span>

// usePotionOfRestoreStrength restores lost strength
func usePotionOfRestoreStrength(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement strength restoration
        return &amp;EffectResult{
                Message:    "You feel your strength returning.",
                Success:    true,
                Identified: true,
        }
}</span>

// usePotionOfGainStrength permanently increases strength
func usePotionOfGainStrength(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        player.Attack += 2
        return &amp;EffectResult{
                Message:    "You feel stronger!",
                Success:    true,
                Identified: true,
        }
}</span>

// usePotionOfGainExperience grants experience points
func usePotionOfGainExperience(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        expGain := 100 + rand.Intn(200)
        player.GainExp(expGain)
        return &amp;EffectResult{
                Message:    fmt.Sprintf("You feel more experienced! (%d exp)", expGain),
                Success:    true,
                Identified: true,
        }
}</span>

// usePotionOfSeeInvisible grants ability to see invisible creatures
func usePotionOfSeeInvisible(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement see invisible effect
        return &amp;EffectResult{
                Message:    "Your eyes tingle.",
                Success:    true,
                Identified: true,
        }
}</span>

// usePotionOfBlindness temporarily blinds the player
func usePotionOfBlindness(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement blindness effect
        return &amp;EffectResult{
                Message:    "A cloak of darkness falls around you.",
                Success:    true,
                Identified: true,
        }
}</span>

// usePotionOfParalysis temporarily paralyzes the player
func usePotionOfParalysis(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement paralysis effect
        return &amp;EffectResult{
                Message:    "You can't move!",
                Success:    true,
                Identified: true,
        }
}</span>

// usePotionOfConfusion confuses the player
func usePotionOfConfusion(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        // TODO: Implement confusion effect
        return &amp;EffectResult{
                Message:    "Wait, what's going on here? Huh? What? Who?",
                Success:    true,
                Identified: true,
        }
}</span>

// usePotionOfPoison poisons the player
func usePotionOfPoison(player *actor.Player) *EffectResult <span class="cov0" title="0">{
        damage := 3 + rand.Intn(5)
        player.TakeDamage(damage)
        return &amp;EffectResult{
                Message:    fmt.Sprintf("You feel very sick. (%d damage)", damage),
                Success:    true,
                Identified: true,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package screen ゲーム画面の描画と入力処理を提供
// Gruidライブラリを使用したローグライクゲームのUI管理
package screen

import (
        "github.com/anaseto/gruid"
        "github.com/yuru-sha/gorogue/internal/core/cli"
        "github.com/yuru-sha/gorogue/internal/core/wizard"
        "github.com/yuru-sha/gorogue/internal/game/actor"
        "github.com/yuru-sha/gorogue/internal/game/dungeon"
        gameitem "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// InputMode represents the current input mode
type InputMode int

const (
        ModeNormal InputMode = iota
        ModeEquip
        ModeUnequip
        ModeDrop
        ModeQuaff
        ModeRead
        ModeCLI
)

// GameScreen handles the main game display
type GameScreen struct {
        width, height   int
        player          *actor.Player
        level           *dungeon.Level
        dungeonManager  *dungeon.DungeonManager
        messages        []string
        lastStats       map[string]interface{} // 前回のステータス情報
        grid            gruid.Grid             // 画面全体のグリッド
        wizardMode      *wizard.WizardMode     // ウィザードモード
        cliMode         *cli.CLIMode           // CLIデバッグモード
        inputMode       InputMode              // 現在の入力モード
        equippableItems []*gameitem.Item       // 装備可能アイテムリスト
        cliBuffer       string                 // CLI入力バッファ
        cliHistory      []string               // CLIコマンド履歴
}

// NewGameScreen creates a new game screen
func NewGameScreen(width, height int, player *actor.Player) *GameScreen <span class="cov0" title="0">{
        screen := &amp;GameScreen{
                width:           width,
                height:          height,
                player:          player,
                messages:        make([]string, 0, 7), // 7行分のメッセージを保持
                lastStats:       make(map[string]interface{}),
                grid:            gruid.NewGrid(width, height),
                inputMode:       ModeNormal,
                equippableItems: make([]*gameitem.Item, 0),
                cliBuffer:       "",
                cliHistory:      make([]string, 0),
        }

        // PyRogue風の初期メッセージを追加
        screen.AddMessage("Welcome to PyRogue!")
        screen.AddMessage("Use vi keys (hjkl), arrow keys, or numpad (1-9) to move.")
        screen.AddMessage("You are a skilled warrior.")
        screen.AddMessage("You are equipped with a dagger and leather armor.")
        screen.AddMessage("You start with no rings, potions, scrolls, food, and a scroll.")
        screen.AddMessage("You see a lit room.")
        screen.AddMessage("You enter the dungeon. Your quest begins!")

        logger.Debug("Created game screen",
                "width", width,
                "height", height,
        )
        return screen
}</span>

// SetLevel sets the dungeon level for the game screen
func (s *GameScreen) SetLevel(level *dungeon.Level) <span class="cov0" title="0">{
        s.level = level
        s.wizardMode = wizard.NewWizardMode(level, s.player)
        s.cliMode = cli.NewCLIMode(level, s.player)
        logger.Debug("Set dungeon level for game screen",
                "width", level.Width,
                "height", level.Height,
        )
}</span>

// SetDungeonManager sets the dungeon manager for the game screen
func (s *GameScreen) SetDungeonManager(dm *dungeon.DungeonManager) <span class="cov0" title="0">{
        s.dungeonManager = dm
        logger.Debug("Set dungeon manager for game screen")
}</span>

// AddMessage adds a message to the message log
func (s *GameScreen) AddMessage(msg string) <span class="cov0" title="0">{
        s.messages = append(s.messages, msg)
        if len(s.messages) &gt; 7 </span><span class="cov0" title="0">{
                s.messages = s.messages[len(s.messages)-7:]
        }</span>
        <span class="cov0" title="0">logger.Debug("Added message to log",
                "message", msg,
                "messages_count", len(s.messages),
        )</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package screen

import (
        "fmt"

        "github.com/yuru-sha/gorogue/internal/game/actor"
        gameitem "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// tryMovePlayer attempts to move the player in the given direction
func (s *GameScreen) tryMovePlayer(dx, dy int) <span class="cov0" title="0">{
        newX := s.player.Position.X + dx
        newY := s.player.Position.Y + dy

        // 境界チェック
        if newX &lt; 0 || newX &gt;= s.level.Width || newY &lt; 0 || newY &gt;= s.level.Height </span><span class="cov0" title="0">{
                logger.Debug("Player movement blocked by bounds",
                        "current_x", s.player.Position.X,
                        "current_y", s.player.Position.Y,
                        "new_x", newX,
                        "new_y", newY,
                )
                return
        }</span>

        // 壁の衝突判定
        <span class="cov0" title="0">tile := s.level.GetTile(newX, newY)
        if !tile.Walkable() </span><span class="cov0" title="0">{
                logger.Debug("Player movement blocked by wall",
                        "current_x", s.player.Position.X,
                        "current_y", s.player.Position.Y,
                        "new_x", newX,
                        "new_y", newY,
                        "tile_type", tile.Type,
                )
                return
        }</span>

        // モンスターとの戦闘判定
        <span class="cov0" title="0">monster := s.level.GetMonsterAt(newX, newY)
        if monster != nil </span><span class="cov0" title="0">{
                s.playerAttackMonster(monster)
                return
        }</span>

        // 移動実行
        <span class="cov0" title="0">s.player.Position.Move(dx, dy)
        logger.Debug("Player moved",
                "new_x", s.player.Position.X,
                "new_y", s.player.Position.Y,
        )

        // アイテムを拾う処理
        s.pickupItem(newX, newY)

        // モンスターのターンを実行
        s.level.UpdateMonsters(s.player)</span>
}

// playerAttackMonster handles player attacking a monster
func (s *GameScreen) playerAttackMonster(monster *actor.Monster) <span class="cov0" title="0">{
        damage := s.player.CalculateDamage(monster.Defense)
        monster.TakeDamage(damage)

        message := fmt.Sprintf("%sに%dのダメージを与えた！", monster.Type.Name, damage)
        s.AddMessage(message)

        if !monster.IsAlive() </span><span class="cov0" title="0">{
                deathMessage := fmt.Sprintf("%sを倒した！", monster.Type.Name)
                s.AddMessage(deathMessage)

                // 経験値とゴールドを取得
                exp := monster.MaxHP + monster.Attack
                gold := monster.MaxHP / 2

                s.player.GainExp(exp)
                s.player.AddGold(gold)

                rewardMessage := fmt.Sprintf("%d経験値、%dゴールドを得た", exp, gold)
                s.AddMessage(rewardMessage)
        }</span> else<span class="cov0" title="0"> {
                // モンスターのターンを実行
                s.level.UpdateMonsters(s.player)
        }</span>
}

// pickupItem handles picking up an item at the given position
func (s *GameScreen) pickupItem(x, y int) <span class="cov0" title="0">{
        item := s.level.GetItemAt(x, y)
        if item == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // インベントリに追加を試行
        <span class="cov0" title="0">if !s.player.Inventory.AddItem(item) </span><span class="cov0" title="0">{
                s.AddMessage("Your pack is full!")
                return
        }</span>

        // アイテムタイプに応じたメッセージ（識別状態を考慮）
        <span class="cov0" title="0">displayName := s.player.IdentifyMgr.GetDisplayName(item)
        switch item.Type </span>{
        case gameitem.ItemGold:<span class="cov0" title="0">
                s.AddMessage(fmt.Sprintf("You found %d gold pieces", item.Value))</span>
        case gameitem.ItemAmulet:<span class="cov0" title="0">
                s.AddMessage(fmt.Sprintf("You picked up the %s!", displayName))</span>
        default:<span class="cov0" title="0">
                s.AddMessage(fmt.Sprintf("You picked up %s", displayName))</span>
        }

        // アイテムをレベルから削除
        <span class="cov0" title="0">s.level.RemoveItem(item)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package screen

import (
        "fmt"

        "github.com/anaseto/gruid"
        "github.com/yuru-sha/gorogue/internal/core/state"
        gameitem "github.com/yuru-sha/gorogue/internal/game/item"
        "github.com/yuru-sha/gorogue/internal/game/magic"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// HandleInput handles input events
func (s *GameScreen) HandleInput(msg gruid.Msg) state.GameState <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case gruid.MsgKeyDown:<span class="cov0" title="0">
                // モード別の処理
                switch s.inputMode </span>{
                case ModeEquip:<span class="cov0" title="0">
                        return s.handleEquipInput(msg.Key)</span>
                case ModeUnequip:<span class="cov0" title="0">
                        return s.handleUnequipInput(msg.Key)</span>
                case ModeDrop:<span class="cov0" title="0">
                        return s.handleDropInput(msg.Key)</span>
                case ModeQuaff:<span class="cov0" title="0">
                        return s.handleQuaffInput(msg.Key)</span>
                case ModeRead:<span class="cov0" title="0">
                        return s.handleReadInput(msg.Key)</span>
                case ModeCLI:<span class="cov0" title="0">
                        return s.handleCLIInput(msg.Key)</span>
                default:<span class="cov0" title="0"> // ModeNormal
                        return s.handleNormalInput(msg.Key)</span>
                }
        }
        <span class="cov0" title="0">return state.StateGame</span>
}

// handleNormalInput handles input in normal mode
func (s *GameScreen) handleNormalInput(key gruid.Key) state.GameState <span class="cov0" title="0">{
        switch key </span>{
        case gruid.KeyEscape:<span class="cov0" title="0">
                logger.Info("Returning to menu")
                return state.StateMenu</span>
        case "Left", "h", gruid.KeyArrowLeft:<span class="cov0" title="0">
                s.tryMovePlayer(-1, 0)</span>
        case "Right", "l", gruid.KeyArrowRight:<span class="cov0" title="0">
                s.tryMovePlayer(1, 0)</span>
        case "Up", "k", gruid.KeyArrowUp:<span class="cov0" title="0">
                s.tryMovePlayer(0, -1)</span>
        case "Down", "j", gruid.KeyArrowDown:<span class="cov0" title="0">
                s.tryMovePlayer(0, 1)</span>
        case "y":<span class="cov0" title="0">
                s.tryMovePlayer(-1, -1)</span>
        case "u":<span class="cov0" title="0">
                s.tryMovePlayer(1, -1)</span>
        case "b":<span class="cov0" title="0">
                s.tryMovePlayer(-1, 1)</span>
        case "n":<span class="cov0" title="0">
                s.tryMovePlayer(1, 1)</span>
        case "Q":<span class="cov0" title="0">
                logger.Info("Quit requested")
                return state.StateMenu</span>
        case "&lt;", ",":<span class="cov0" title="0"> // Go upstairs
                s.handleStairs(true)</span>
        case "&gt;", ".":<span class="cov0" title="0"> // Go downstairs
                s.handleStairs(false)</span>
        case "i":<span class="cov0" title="0"> // Show inventory
                s.showInventory()</span>
        case "d":<span class="cov0" title="0"> // Drop item
                s.enterDropMode()</span>
        case "w":<span class="cov0" title="0"> // Wield/wear item
                s.enterEquipMode()</span>
        case "t":<span class="cov0" title="0"> // Take off item
                s.enterUnequipMode()</span>
        case "q":<span class="cov0" title="0"> // Quaff potion
                s.enterQuaffMode()</span>
        case "r":<span class="cov0" title="0"> // Read scroll
                s.enterReadMode()</span>
        case ":":<span class="cov0" title="0"> // Enter CLI mode
                s.enterCLIMode()</span>
        case "^W", "W":<span class="cov0" title="0"> // Ctrl+W or Shift+W to toggle wizard mode
                s.wizardMode.Toggle()
                status := "OFF"
                if s.wizardMode.IsActive </span><span class="cov0" title="0">{
                        status = "ON"
                }</span>
                <span class="cov0" title="0">s.AddMessage(fmt.Sprintf("ウィザードモード: %s", status))</span>
        default:<span class="cov0" title="0">
                // Check if it's a wizard command
                if s.wizardMode.IsActive &amp;&amp; len(string(key)) == 1 </span><span class="cov0" title="0">{
                        result := s.wizardMode.ExecuteCommand(rune(string(key)[0]))
                        if result != "" </span><span class="cov0" title="0">{
                                s.AddMessage(result)
                        }</span>
                }
        }
        <span class="cov0" title="0">return state.StateGame</span>
}

// handleStairs handles stair movement
func (s *GameScreen) handleStairs(goUp bool) <span class="cov0" title="0">{
        if s.dungeonManager == nil </span><span class="cov0" title="0">{
                s.AddMessage("Dungeon manager not available")
                return
        }</span>

        <span class="cov0" title="0">if goUp </span><span class="cov0" title="0">{
                if s.dungeonManager.CanGoUpstairs() </span><span class="cov0" title="0">{
                        if s.dungeonManager.GoUpstairs() </span><span class="cov0" title="0">{
                                s.level = s.dungeonManager.GetCurrentLevel()
                                s.wizardMode.SetLevel(s.level)
                                s.AddMessage(fmt.Sprintf("階層 %d へ上がった", s.dungeonManager.GetCurrentFloor()))
                        }</span>
                } else<span class="cov0" title="0"> {
                        s.AddMessage("ここには上り階段がない")
                }</span>
        } else<span class="cov0" title="0"> {
                if s.dungeonManager.CanGoDownstairs() </span><span class="cov0" title="0">{
                        if s.dungeonManager.GoDownstairs() </span><span class="cov0" title="0">{
                                s.level = s.dungeonManager.GetCurrentLevel()
                                s.wizardMode.SetLevel(s.level)
                                s.AddMessage(fmt.Sprintf("階層 %d へ下りた", s.dungeonManager.GetCurrentFloor()))

                                // 最終階層に到達した場合、イェンダーの魔除けを配置
                                if s.dungeonManager.IsOnFinalFloor() </span><span class="cov0" title="0">{
                                        s.dungeonManager.PlaceAmuletOfYendor()
                                        s.AddMessage("この階層には強力な魔力を感じる...")
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        s.AddMessage("ここには下り階段がない")
                }</span>
        }
}

// handleEquipInput handles input in equip mode
func (s *GameScreen) handleEquipInput(key gruid.Key) state.GameState <span class="cov0" title="0">{
        switch key </span>{
        case gruid.KeyEscape:<span class="cov0" title="0">
                s.inputMode = ModeNormal
                s.AddMessage("Canceled.")
                return state.StateGame</span>
        default:<span class="cov0" title="0">
                if len(string(key)) == 1 &amp;&amp; string(key)[0] &gt;= 'a' &amp;&amp; string(key)[0] &lt;= 'z' </span><span class="cov0" title="0">{
                        index := int(string(key)[0] - 'a')
                        if index &lt; len(s.equippableItems) </span><span class="cov0" title="0">{
                                item := s.equippableItems[index]
                                if s.player.Equipment.EquipItem(item) </span><span class="cov0" title="0">{
                                        // インベントリからアイテムを削除
                                        for i, invItem := range s.player.Inventory.Items </span><span class="cov0" title="0">{
                                                if invItem == item </span><span class="cov0" title="0">{
                                                        s.player.Inventory.RemoveItem(i)
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">displayName := s.player.IdentifyMgr.GetDisplayName(item)
                                        s.AddMessage(fmt.Sprintf("You equipped %s.", displayName))</span>
                                } else<span class="cov0" title="0"> {
                                        s.AddMessage("You can't equip that item.")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                s.AddMessage("Invalid selection.")
                        }</span>
                        <span class="cov0" title="0">s.inputMode = ModeNormal</span>
                }
        }
        <span class="cov0" title="0">return state.StateGame</span>
}

// handleUnequipInput handles input in unequip mode
func (s *GameScreen) handleUnequipInput(key gruid.Key) state.GameState <span class="cov0" title="0">{
        switch key </span>{
        case gruid.KeyEscape:<span class="cov0" title="0">
                s.inputMode = ModeNormal
                s.AddMessage("Canceled.")
                return state.StateGame</span>
        case "w":<span class="cov0" title="0"> // Unequip weapon
                s.unequipSlot("weapon", "weapon")</span>
        case "a":<span class="cov0" title="0"> // Unequip armor
                s.unequipSlot("armor", "armor")</span>
        case "l":<span class="cov0" title="0"> // Unequip left ring
                s.unequipSlot("ring_left", "left ring")</span>
        case "r":<span class="cov0" title="0"> // Unequip right ring
                s.unequipSlot("ring_right", "right ring")</span>
        default:<span class="cov0" title="0">
                s.AddMessage("Invalid selection. Use (w)eapon, (a)rmor, (l)eft ring, (r)ight ring")</span>
        }
        <span class="cov0" title="0">s.inputMode = ModeNormal
        return state.StateGame</span>
}

// unequipSlot unequips an item from a specific slot
func (s *GameScreen) unequipSlot(slot, displaySlot string) <span class="cov0" title="0">{
        if item := s.player.Equipment.UnequipItem(slot); item != nil </span><span class="cov0" title="0">{
                if s.player.Inventory.AddItem(item) </span><span class="cov0" title="0">{
                        displayName := s.player.IdentifyMgr.GetDisplayName(item)
                        s.AddMessage(fmt.Sprintf("You took off %s.", displayName))
                }</span> else<span class="cov0" title="0"> {
                        s.AddMessage("Your pack is full!")
                        // 装備を戻す
                        s.player.Equipment.EquipItem(item)
                }</span>
        } else<span class="cov0" title="0"> {
                s.AddMessage(fmt.Sprintf("You have no %s equipped.", displaySlot))
        }</span>
}

// handleDropInput handles input in drop mode
func (s *GameScreen) handleDropInput(key gruid.Key) state.GameState <span class="cov0" title="0">{
        switch key </span>{
        case gruid.KeyEscape:<span class="cov0" title="0">
                s.inputMode = ModeNormal
                s.AddMessage("Canceled.")
                return state.StateGame</span>
        default:<span class="cov0" title="0">
                if len(string(key)) == 1 &amp;&amp; string(key)[0] &gt;= 'a' &amp;&amp; string(key)[0] &lt;= 'z' </span><span class="cov0" title="0">{
                        index := int(string(key)[0] - 'a')
                        if item := s.player.Inventory.GetItem(index); item != nil </span><span class="cov0" title="0">{
                                displayName := s.player.IdentifyMgr.GetDisplayName(item)
                                s.AddMessage(fmt.Sprintf("You dropped %s.", displayName))
                                // アイテムをプレイヤーの位置に配置
                                s.level.AddItem(item, s.player.Position.X, s.player.Position.Y)
                                s.player.Inventory.RemoveItem(index)
                        }</span> else<span class="cov0" title="0"> {
                                s.AddMessage("Invalid selection.")
                        }</span>
                        <span class="cov0" title="0">s.inputMode = ModeNormal</span>
                }
        }
        <span class="cov0" title="0">return state.StateGame</span>
}

// handleQuaffInput handles input in quaff mode
func (s *GameScreen) handleQuaffInput(key gruid.Key) state.GameState <span class="cov0" title="0">{
        switch key </span>{
        case gruid.KeyEscape:<span class="cov0" title="0">
                s.inputMode = ModeNormal
                s.AddMessage("Canceled.")
                return state.StateGame</span>
        default:<span class="cov0" title="0">
                if len(string(key)) == 1 &amp;&amp; string(key)[0] &gt;= 'a' &amp;&amp; string(key)[0] &lt;= 'z' </span><span class="cov0" title="0">{
                        index := int(string(key)[0] - 'a')
                        if item := s.player.Inventory.GetItem(index); item != nil </span><span class="cov0" title="0">{
                                if item.Type == gameitem.ItemPotion </span><span class="cov0" title="0">{
                                        result := magic.UsePotion(item.Name, s.player)
                                        s.AddMessage(result.Message)

                                        if result.Identified </span><span class="cov0" title="0">{
                                                s.player.IdentifyMgr.IdentifyByUse(item)
                                        }</span>

                                        // ポーションを消費
                                        <span class="cov0" title="0">s.player.Inventory.RemoveItem(index)</span>
                                } else<span class="cov0" title="0"> {
                                        s.AddMessage("You can't drink that!")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                s.AddMessage("Invalid selection.")
                        }</span>
                        <span class="cov0" title="0">s.inputMode = ModeNormal</span>
                }
        }
        <span class="cov0" title="0">return state.StateGame</span>
}

// handleReadInput handles input in read mode
func (s *GameScreen) handleReadInput(key gruid.Key) state.GameState <span class="cov0" title="0">{
        switch key </span>{
        case gruid.KeyEscape:<span class="cov0" title="0">
                s.inputMode = ModeNormal
                s.AddMessage("Canceled.")
                return state.StateGame</span>
        default:<span class="cov0" title="0">
                if len(string(key)) == 1 &amp;&amp; string(key)[0] &gt;= 'a' &amp;&amp; string(key)[0] &lt;= 'z' </span><span class="cov0" title="0">{
                        index := int(string(key)[0] - 'a')
                        if item := s.player.Inventory.GetItem(index); item != nil </span><span class="cov0" title="0">{
                                if item.Type == gameitem.ItemScroll </span><span class="cov0" title="0">{
                                        result := magic.UseScroll(item.Name, s.player, s.level)
                                        s.AddMessage(result.Message)

                                        if result.Identified </span><span class="cov0" title="0">{
                                                s.player.IdentifyMgr.IdentifyByUse(item)
                                        }</span>

                                        // 巻物を消費
                                        <span class="cov0" title="0">s.player.Inventory.RemoveItem(index)</span>
                                } else<span class="cov0" title="0"> {
                                        s.AddMessage("You can't read that!")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                s.AddMessage("Invalid selection.")
                        }</span>
                        <span class="cov0" title="0">s.inputMode = ModeNormal</span>
                }
        }
        <span class="cov0" title="0">return state.StateGame</span>
}

// handleCLIInput handles input in CLI mode
func (s *GameScreen) handleCLIInput(key gruid.Key) state.GameState <span class="cov0" title="0">{
        switch key </span>{
        case gruid.KeyEscape:<span class="cov0" title="0">
                s.inputMode = ModeNormal
                s.cliBuffer = ""
                s.AddMessage("CLI mode exited.")
                return state.StateGame</span>
        case gruid.KeyEnter:<span class="cov0" title="0">
                if s.cliBuffer != "" </span><span class="cov0" title="0">{
                        // Execute command
                        result := s.cliMode.ExecuteCommand(s.cliBuffer)
                        s.AddMessage(fmt.Sprintf("&gt; %s", s.cliBuffer))
                        s.AddMessage(result)

                        // Add to history
                        s.cliHistory = append(s.cliHistory, s.cliBuffer)
                        if len(s.cliHistory) &gt; 20 </span><span class="cov0" title="0">{
                                s.cliHistory = s.cliHistory[1:]
                        }</span>

                        <span class="cov0" title="0">s.cliBuffer = ""</span>
                }
                <span class="cov0" title="0">s.inputMode = ModeNormal
                return state.StateGame</span>
        case gruid.KeyBackspace:<span class="cov0" title="0">
                if s.cliBuffer != "" </span><span class="cov0" title="0">{
                        s.cliBuffer = s.cliBuffer[:len(s.cliBuffer)-1]
                }</span>
                <span class="cov0" title="0">return state.StateGame</span>
        default:<span class="cov0" title="0">
                // Add character to buffer
                if len(string(key)) == 1 </span><span class="cov0" title="0">{
                        char := string(key)[0]
                        if char &gt;= 32 &amp;&amp; char &lt;= 126 </span><span class="cov0" title="0">{ // Printable ASCII
                                s.cliBuffer += string(char)
                        }</span>
                }
                <span class="cov0" title="0">return state.StateGame</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package screen

import (
        "fmt"

        gameitem "github.com/yuru-sha/gorogue/internal/game/item"
)

// showInventory displays the player's inventory
func (s *GameScreen) showInventory() <span class="cov0" title="0">{
        listing := s.player.Inventory.GetInventoryListing(s.player.IdentifyMgr)
        for _, line := range listing </span><span class="cov0" title="0">{
                s.AddMessage(line)
        }</span>
}

// enterEquipMode enters equipment selection mode
func (s *GameScreen) enterEquipMode() <span class="cov0" title="0">{
        if s.player.Inventory.IsEmpty() </span><span class="cov0" title="0">{
                s.AddMessage("You have nothing to equip.")
                return
        }</span>

        // 装備可能なアイテムをリストアップ
        <span class="cov0" title="0">s.equippableItems = make([]*gameitem.Item, 0)
        for _, item := range s.player.Inventory.Items </span><span class="cov0" title="0">{
                if s.canEquip(item) </span><span class="cov0" title="0">{
                        s.equippableItems = append(s.equippableItems, item)
                }</span>
        }

        <span class="cov0" title="0">if len(s.equippableItems) == 0 </span><span class="cov0" title="0">{
                s.AddMessage("You have no equippable items.")
                return
        }</span>

        <span class="cov0" title="0">s.inputMode = ModeEquip
        s.showEquipMenu()</span>
}

// showEquipMenu shows the equip item menu
func (s *GameScreen) showEquipMenu() <span class="cov0" title="0">{
        s.AddMessage("Equippable items:")
        for i, item := range s.equippableItems </span><span class="cov0" title="0">{
                letter := rune('a' + i)
                displayName := s.player.IdentifyMgr.GetDisplayName(item)
                s.AddMessage(fmt.Sprintf("%c) %s", letter, displayName))
        }</span>
        <span class="cov0" title="0">s.AddMessage("Equip which item? (a-z, ESC to cancel)")</span>
}

// enterUnequipMode enters unequip selection mode
func (s *GameScreen) enterUnequipMode() <span class="cov0" title="0">{
        // 現在装備しているアイテムがあるかチェック
        if s.player.Equipment.Weapon == nil &amp;&amp; s.player.Equipment.Armor == nil &amp;&amp;
                s.player.Equipment.RingLeft == nil &amp;&amp; s.player.Equipment.RingRight == nil </span><span class="cov0" title="0">{
                s.AddMessage("You have nothing equipped to take off.")
                return
        }</span>

        <span class="cov0" title="0">s.inputMode = ModeUnequip
        s.showUnequipMenu()</span>
}

// showUnequipMenu shows the unequip item menu
func (s *GameScreen) showUnequipMenu() <span class="cov0" title="0">{
        // 現在装備しているアイテムをチェック
        equippedItems := make([]string, 0)

        if s.player.Equipment.Weapon != nil </span><span class="cov0" title="0">{
                weaponName := s.player.IdentifyMgr.GetDisplayName(s.player.Equipment.Weapon)
                equippedItems = append(equippedItems, fmt.Sprintf("(w) %s", weaponName))
        }</span>
        <span class="cov0" title="0">if s.player.Equipment.Armor != nil </span><span class="cov0" title="0">{
                armorName := s.player.IdentifyMgr.GetDisplayName(s.player.Equipment.Armor)
                equippedItems = append(equippedItems, fmt.Sprintf("(a) %s", armorName))
        }</span>
        <span class="cov0" title="0">if s.player.Equipment.RingLeft != nil </span><span class="cov0" title="0">{
                ringName := s.player.IdentifyMgr.GetDisplayName(s.player.Equipment.RingLeft)
                equippedItems = append(equippedItems, fmt.Sprintf("(l) %s", ringName))
        }</span>
        <span class="cov0" title="0">if s.player.Equipment.RingRight != nil </span><span class="cov0" title="0">{
                ringName := s.player.IdentifyMgr.GetDisplayName(s.player.Equipment.RingRight)
                equippedItems = append(equippedItems, fmt.Sprintf("(r) %s", ringName))
        }</span>

        <span class="cov0" title="0">if len(equippedItems) == 0 </span><span class="cov0" title="0">{
                s.AddMessage("You have nothing equipped to take off.")
                return
        }</span>

        <span class="cov0" title="0">s.AddMessage("Currently equipped:")
        for _, item := range equippedItems </span><span class="cov0" title="0">{
                s.AddMessage(item)
        }</span>
        <span class="cov0" title="0">s.AddMessage("Take off which item? (w)eapon, (a)rmor, (l)eft ring, (r)ight ring")</span>
}

// enterDropMode enters drop selection mode
func (s *GameScreen) enterDropMode() <span class="cov0" title="0">{
        if s.player.Inventory.IsEmpty() </span><span class="cov0" title="0">{
                s.AddMessage("You have nothing to drop.")
                return
        }</span>

        <span class="cov0" title="0">s.inputMode = ModeDrop
        s.showDropMenu()</span>
}

// showDropMenu shows the drop item menu
func (s *GameScreen) showDropMenu() <span class="cov0" title="0">{
        listing := s.player.Inventory.GetInventoryListing(s.player.IdentifyMgr)
        for _, line := range listing </span><span class="cov0" title="0">{
                s.AddMessage(line)
        }</span>
        <span class="cov0" title="0">s.AddMessage("Drop which item? (a-z, ESC to cancel)")</span>
}

// enterQuaffMode enters potion quaffing mode
func (s *GameScreen) enterQuaffMode() <span class="cov0" title="0">{
        if s.player.Inventory.IsEmpty() </span><span class="cov0" title="0">{
                s.AddMessage("You have no potions to drink.")
                return
        }</span>

        // ポーションをリストアップ
        <span class="cov0" title="0">potions := make([]*gameitem.Item, 0)
        for _, item := range s.player.Inventory.Items </span><span class="cov0" title="0">{
                if item.Type == gameitem.ItemPotion </span><span class="cov0" title="0">{
                        potions = append(potions, item)
                }</span>
        }

        <span class="cov0" title="0">if len(potions) == 0 </span><span class="cov0" title="0">{
                s.AddMessage("You have no potions to drink.")
                return
        }</span>

        <span class="cov0" title="0">s.inputMode = ModeQuaff
        s.showPotions()</span>
}

// showPotions displays available potions
func (s *GameScreen) showPotions() <span class="cov0" title="0">{
        s.AddMessage("Available potions:")
        index := 0
        for i, item := range s.player.Inventory.Items </span><span class="cov0" title="0">{
                if item.Type == gameitem.ItemPotion </span><span class="cov0" title="0">{
                        letter := rune('a' + i)
                        displayName := s.player.IdentifyMgr.GetDisplayName(item)
                        s.AddMessage(fmt.Sprintf("%c) %s", letter, displayName))
                        index++
                }</span>
        }
        <span class="cov0" title="0">s.AddMessage("Quaff which potion? (a-z, ESC to cancel)")</span>
}

// enterReadMode enters scroll reading mode
func (s *GameScreen) enterReadMode() <span class="cov0" title="0">{
        if s.player.Inventory.IsEmpty() </span><span class="cov0" title="0">{
                s.AddMessage("You have no scrolls to read.")
                return
        }</span>

        // 巻物をリストアップ
        <span class="cov0" title="0">scrolls := make([]*gameitem.Item, 0)
        for _, item := range s.player.Inventory.Items </span><span class="cov0" title="0">{
                if item.Type == gameitem.ItemScroll </span><span class="cov0" title="0">{
                        scrolls = append(scrolls, item)
                }</span>
        }

        <span class="cov0" title="0">if len(scrolls) == 0 </span><span class="cov0" title="0">{
                s.AddMessage("You have no scrolls to read.")
                return
        }</span>

        <span class="cov0" title="0">s.inputMode = ModeRead
        s.showScrolls()</span>
}

// showScrolls displays available scrolls
func (s *GameScreen) showScrolls() <span class="cov0" title="0">{
        s.AddMessage("Available scrolls:")
        index := 0
        for i, item := range s.player.Inventory.Items </span><span class="cov0" title="0">{
                if item.Type == gameitem.ItemScroll </span><span class="cov0" title="0">{
                        letter := rune('a' + i)
                        displayName := s.player.IdentifyMgr.GetDisplayName(item)
                        s.AddMessage(fmt.Sprintf("%c) %s", letter, displayName))
                        index++
                }</span>
        }
        <span class="cov0" title="0">s.AddMessage("Read which scroll? (a-z, ESC to cancel)")</span>
}

// enterCLIMode enters CLI debug mode
func (s *GameScreen) enterCLIMode() <span class="cov0" title="0">{
        if s.cliMode == nil </span><span class="cov0" title="0">{
                s.AddMessage("CLI mode not available.")
                return
        }</span>

        <span class="cov0" title="0">s.cliMode.IsActive = true
        s.inputMode = ModeCLI
        s.cliBuffer = ""
        s.AddMessage("Entered CLI mode. Type 'help' for commands, ESC to exit.")
        s.AddMessage("CLI&gt; ")</span>
}

// canEquip checks if an item can be equipped
func (s *GameScreen) canEquip(item *gameitem.Item) bool <span class="cov0" title="0">{
        switch item.Type </span>{
        case gameitem.ItemWeapon, gameitem.ItemArmor, gameitem.ItemRing:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package screen

import (
        "fmt"
        "reflect"

        "github.com/anaseto/gruid"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

// Draw draws the game screen
func (s *GameScreen) Draw(grid *gruid.Grid) <span class="cov0" title="0">{
        // Collect current status information
        currentStats := s.collectCurrentStats()

        // Log output only when status has changed
        if !reflect.DeepEqual(s.lastStats, currentStats) </span><span class="cov0" title="0">{
                s.logStatsChange()
                s.lastStats = currentStats
        }</span>

        // Output detailed drawing logs at TRACE level
        <span class="cov0" title="0">logger.Trace("Drawing game screen")

        // Clear grid - original Rogue-style black background
        grid.Fill(gruid.Cell{Rune: ' ', Style: gruid.Style{Bg: 0x000000}})

        // Draw status lines (top 2 rows)
        s.drawStatusLines(grid)

        // Draw dungeon
        s.drawDungeon(grid)

        // Draw entities (items, monsters, player)
        s.drawEntities(grid)

        // Draw message log (bottom 7 rows)
        s.drawMessageLog(grid)

        // CLIモードの表示
        if s.inputMode == ModeCLI </span><span class="cov0" title="0">{
                s.drawCLIPrompt(grid)
        }</span>
}

// collectCurrentStats collects current player stats for change detection
func (s *GameScreen) collectCurrentStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "level":   s.player.Level,
                "hp":      s.player.HP,
                "max_hp":  s.player.MaxHP,
                "attack":  s.player.Attack,
                "defense": s.player.Defense,
                "hunger":  s.player.Hunger,
                "exp":     s.player.Exp,
                "gold":    s.player.Gold,
        }
}</span>

// logStatsChange logs when player stats change
func (s *GameScreen) logStatsChange() <span class="cov0" title="0">{
        logger.Debug("Player stats changed",
                "level", s.player.Level,
                "hp", s.player.HP,
                "max_hp", s.player.MaxHP,
                "attack", s.player.Attack,
                "defense", s.player.Defense,
                "hunger", s.player.Hunger,
                "exp", s.player.Exp,
                "gold", s.player.Gold,
        )
}</span>

// drawStatusLines draws the status information at the top
func (s *GameScreen) drawStatusLines(grid *gruid.Grid) <span class="cov0" title="0">{
        currentFloor := 1
        if s.dungeonManager != nil </span><span class="cov0" title="0">{
                currentFloor = s.dungeonManager.GetCurrentFloor()
        }</span>

        // 第1行: プレイヤーステータス
        <span class="cov0" title="0">statusLine1 := fmt.Sprintf(
                "Lv:%d  HP:%d/%d  Atk:%d  Def:%d  Hunger:%d%%  Exp:%d  Gold:%d",
                s.player.Level,
                s.player.HP,
                s.player.MaxHP,
                s.player.Attack,
                s.player.Defense,
                s.player.Hunger,
                s.player.Exp,
                s.player.Gold,
        )
        s.drawText(grid, 0, 0, statusLine1, gruid.Style{Fg: 0xFFFFFF, Bg: 0x000000})

        // 右上に階層表示を追加
        floorDisplay := fmt.Sprintf("B%dF", currentFloor)
        s.drawText(grid, s.width-len(floorDisplay), 0, floorDisplay, gruid.Style{Fg: 0xFFFFFF, Bg: 0x000000})

        // 第2行: 装備情報
        s.drawEquipmentLine(grid)</span>
}

// drawEquipmentLine draws the equipment status line
func (s *GameScreen) drawEquipmentLine(grid *gruid.Grid) <span class="cov0" title="0">{
        weapon, armor, ringLeft, ringRight := s.player.Equipment.GetEquippedNames()
        statusLine2 := fmt.Sprintf(
                "Weapon: %-15s  Armor: %-15s  Ring: (L): %-10s  Ring: (R): %-10s",
                weapon,
                armor,
                ringLeft,
                ringRight,
        )

        // ウィザードモードの表示を追加
        if s.wizardMode != nil &amp;&amp; s.wizardMode.IsActive </span><span class="cov0" title="0">{
                statusLine2 += "  [WIZARD MODE]"
        }</span>

        <span class="cov0" title="0">s.drawText(grid, 0, 1, statusLine2, gruid.Style{Fg: 0xFFFFFF, Bg: 0x000000})</span>
}

// drawDungeon draws the dungeon tiles
func (s *GameScreen) drawDungeon(grid *gruid.Grid) <span class="cov0" title="0">{
        for y := 0; y &lt; s.level.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; s.level.Width; x++ </span><span class="cov0" title="0">{
                        tile := s.level.GetTile(x, y)
                        grid.Set(gruid.Point{X: x, Y: y + 2}, gruid.Cell{
                                Rune:  tile.Rune,
                                Style: gruid.Style{Fg: tile.Color, Bg: 0x000000},
                        })
                }</span>
        }
}

// drawEntities draws all entities (items, monsters, player)
func (s *GameScreen) drawEntities(grid *gruid.Grid) <span class="cov0" title="0">{
        // アイテムの描画（最初に描画）
        for _, item := range s.level.Items </span><span class="cov0" title="0">{
                grid.Set(gruid.Point{X: item.Position.X, Y: item.Position.Y + 2}, gruid.Cell{
                        Rune:  item.Symbol,
                        Style: gruid.Style{Fg: item.Color, Bg: 0x000000},
                })
        }</span>

        // モンスターの描画（アイテムの上に描画）
        <span class="cov0" title="0">for _, monster := range s.level.Monsters </span><span class="cov0" title="0">{
                if monster.IsAlive() </span><span class="cov0" title="0">{
                        grid.Set(gruid.Point{X: monster.Position.X, Y: monster.Position.Y + 2}, gruid.Cell{
                                Rune:  monster.Type.Symbol,
                                Style: gruid.Style{Fg: monster.Color, Bg: 0x000000},
                        })
                }</span>
        }

        // プレイヤーの描画（最上位に描画）
        <span class="cov0" title="0">grid.Set(gruid.Point{X: s.player.Position.X, Y: s.player.Position.Y + 2}, gruid.Cell{
                Rune:  s.player.Symbol,
                Style: gruid.Style{Fg: s.player.Color, Bg: 0x000000},
        })</span>
}

// drawMessageLog draws the message log at the bottom
func (s *GameScreen) drawMessageLog(grid *gruid.Grid) <span class="cov0" title="0">{
        for i, msg := range s.messages </span><span class="cov0" title="0">{
                s.drawText(grid, 0, s.height-7+i, msg, gruid.Style{Fg: 0xFFFFFF, Bg: 0x000000})
        }</span>
}

// drawCLIPrompt draws the CLI prompt when in CLI mode
func (s *GameScreen) drawCLIPrompt(grid *gruid.Grid) <span class="cov0" title="0">{
        cliPrompt := fmt.Sprintf("CLI&gt; %s_", s.cliBuffer)
        s.drawText(grid, 0, s.height-1, cliPrompt, gruid.Style{Fg: 0x00FF00, Bg: 0x000000}) // 緑色で表示
}</span>

// drawText draws text at the specified position with the given style
func (s *GameScreen) drawText(grid *gruid.Grid, x, y int, text string, style gruid.Style) <span class="cov0" title="0">{
        for i, r := range text </span><span class="cov0" title="0">{
                pos := gruid.Point{X: x + i, Y: y}
                if pos.X &gt;= grid.Size().X </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">grid.Set(pos, gruid.Cell{Rune: r, Style: style})</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package screen

import (
        "github.com/anaseto/gruid"
        "github.com/yuru-sha/gorogue/internal/core/state"
        "github.com/yuru-sha/gorogue/internal/utils/logger"
)

var titleArt = []string{
        "",
        "GoRogue",
        "",
}

var menuBox = []string{
        "",
        "NEW GAME",
        "QUIT",
        "",
}

var version = "v0.1.0"

// Colors
var (
        colorYellow   = gruid.Style{Fg: 3}  // 黄色
        colorGray     = gruid.Style{Fg: 8}  // グレー
        colorWhite    = gruid.Style{Fg: 15} // 白
        colorDarkGray = gruid.Style{Fg: 7}  // 暗いグレー
)

// MenuScreen represents the menu screen
type MenuScreen struct {
        width    int
        height   int
        selected int
        grid     gruid.Grid
}

// NewMenuScreen creates a new menu screen
func NewMenuScreen(width, height int) *MenuScreen <span class="cov0" title="0">{
        return &amp;MenuScreen{
                width:    width,
                height:   height,
                selected: 0,
                grid:     gruid.NewGrid(width, height),
        }
}</span>

// HandleInput handles input events
func (s *MenuScreen) HandleInput(msg gruid.Msg) state.GameState <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case gruid.MsgKeyDown:<span class="cov0" title="0">
                switch msg.Key </span>{
                case "Up":<span class="cov0" title="0">
                        s.selected = 0</span>
                case "Down":<span class="cov0" title="0">
                        s.selected = 1</span>
                case "Enter":<span class="cov0" title="0">
                        if s.selected == 0 </span><span class="cov0" title="0">{
                                logger.Info("Game started from menu")
                                return state.StateGame
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info("Game quit from menu")
                                return state.StateGameOver
                        }</span>
                }
        }

        <span class="cov0" title="0">return state.StateMenu</span>
}

// Draw draws the menu screen
func (s *MenuScreen) Draw(grid *gruid.Grid) <span class="cov0" title="0">{
        // グリッドをクリア
        grid.Fill(gruid.Cell{Rune: ' '})

        // タイトルの描画
        titleY := s.height/4 - len(titleArt)/2
        for i, line := range titleArt </span><span class="cov0" title="0">{
                titleX := (s.width - len(line)) / 2
                s.drawText(grid, titleX, titleY+i, line, colorYellow)
        }</span>

        // メニューの描画
        <span class="cov0" title="0">menuY := titleY + len(titleArt) + 4
        for i, line := range menuBox </span><span class="cov0" title="0">{
                menuX := (s.width - len(line)) / 2
                style := colorGray

                // 選択中の項目をハイライト
                if (i == 1 &amp;&amp; s.selected == 0) || (i == 2 &amp;&amp; s.selected == 1) </span><span class="cov0" title="0">{
                        style = colorWhite
                }</span>

                <span class="cov0" title="0">s.drawText(grid, menuX, menuY+i, line, style)</span>
        }

        // バージョン情報の描画
        <span class="cov0" title="0">versionText := "Version " + version
        versionX := 1
        versionY := s.height - 1
        s.drawText(grid, versionX, versionY, versionText, colorDarkGray)

        // 操作説明の描画
        controlsText := "↑↓:Select  Enter:Decide"
        controlsX := (s.width - len(controlsText)) / 2
        controlsY := menuY + len(menuBox) + 2
        s.drawText(grid, controlsX, controlsY, controlsText, colorGray)

        logger.Trace("Menu screen drawn")</span>
}

// drawText draws text at the specified position with the given style
func (s *MenuScreen) drawText(grid *gruid.Grid, x, y int, text string, style gruid.Style) <span class="cov0" title="0">{
        for i, r := range text </span><span class="cov0" title="0">{
                pos := gruid.Point{X: x + i, Y: y}
                if pos.X &gt;= grid.Size().X </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">grid.Set(pos, gruid.Cell{Rune: r, Style: style})</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package logger

import (
        "fmt"
        "log"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
        "time"
)

const (
        maxGenerations = 5 // Number of log generations to keep
)

var (
        // ログファイルのパス
        logDir    = "logs"
        gameLog   = filepath.Join(logDir, "game.log")
        errorLog  = filepath.Join(logDir, "error.log")
        gameFile  *os.File
        errorFile *os.File

        // slogロガーのインスタンス
        gameLogger  *slog.Logger
        errorLogger *slog.Logger
)

// rotateLogFile rotates log files, keeping maxGenerations
func rotateLogFile(basePath string) error <span class="cov0" title="0">{
        // Remove the oldest log file
        oldestLog := fmt.Sprintf("%s.%d", basePath, maxGenerations)
        os.Remove(oldestLog)

        // Rotate existing log files
        for i := maxGenerations - 1; i &gt;= 1; i-- </span><span class="cov0" title="0">{
                oldPath := fmt.Sprintf("%s.%d", basePath, i)
                newPath := fmt.Sprintf("%s.%d", basePath, i+1)
                // ファイルローテーションのエラーは致命的でないため、ログ出力のみ
                if err := os.Rename(oldPath, newPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        log.Printf("Failed to rotate log file %s: %v", oldPath, err)
                }</span>
        }

        // Rotate current log file
        <span class="cov0" title="0">if _, err := os.Stat(basePath); err == nil </span><span class="cov0" title="0">{
                newPath := fmt.Sprintf("%s.1", basePath)
                if err := os.Rename(basePath, newPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rotate log file: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Setup initializes the logger
func Setup() error <span class="cov0" title="0">{
        // ログディレクトリの作成
        if err := os.MkdirAll(logDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory: %v", err)
        }</span>

        // Rotate log files
        <span class="cov0" title="0">if err := rotateLogFile(gameLog); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := rotateLogFile(errorLog); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // ゲームログファイルの作成
        <span class="cov0" title="0">var err error
        gameFile, err = os.OpenFile(gameLog, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create game log file: %v", err)
        }</span>

        // エラーログファイルの作成
        <span class="cov0" title="0">errorFile, err = os.OpenFile(errorLog, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create error log file: %v", err)
        }</span>

        // JSONハンドラーの作成
        <span class="cov0" title="0">gameOpts := &amp;slog.HandlerOptions{
                Level:     slog.LevelDebug,
                AddSource: true,
        }
        errorOpts := &amp;slog.HandlerOptions{
                Level:     slog.LevelError,
                AddSource: true,
        }

        gameLogger = slog.New(slog.NewJSONHandler(gameFile, gameOpts))
        errorLogger = slog.New(slog.NewJSONHandler(errorFile, errorOpts))

        // 開始ログの出力
        gameLogger.Info("Game Started",
                "start_time", time.Now().Format(time.RFC3339),
                "go_version", runtime.Version(),
                "platform", runtime.GOOS,
                "architecture", runtime.GOARCH,
                "num_cpu", runtime.NumCPU(),
                "max_procs", runtime.GOMAXPROCS(0),
                "process_id", os.Getpid(),
        )

        return nil</span>
}

// Cleanup closes the log files
func Cleanup() <span class="cov0" title="0">{
        if gameFile != nil </span><span class="cov0" title="0">{
                gameFile.Close()
        }</span>
        <span class="cov0" title="0">if errorFile != nil </span><span class="cov0" title="0">{
                errorFile.Close()
        }</span>
}

// addCallerInfo adds caller information to the log attributes
func addCallerInfo(attrs []any) []any <span class="cov0" title="0">{
        pc, file, line, ok := runtime.Caller(2)
        if !ok </span><span class="cov0" title="0">{
                return attrs
        }</span>
        <span class="cov0" title="0">fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov0" title="0">{
                return attrs
        }</span>

        <span class="cov0" title="0">return append(attrs,
                "module", filepath.Base(file),
                "function", fn.Name(),
                "line", line,
        )</span>
}

// Trace logs a trace message
func Trace(msg string, attrs ...any) <span class="cov0" title="0">{
        gameLogger.Debug(msg, addCallerInfo(attrs)...)
}</span>

// Debug logs a debug message
func Debug(msg string, attrs ...any) <span class="cov0" title="0">{
        gameLogger.Debug(msg, addCallerInfo(attrs)...)
}</span>

// Info logs an info message
func Info(msg string, attrs ...any) <span class="cov0" title="0">{
        gameLogger.Info(msg, addCallerInfo(attrs)...)
}</span>

// Warn logs a warning message
func Warn(msg string, attrs ...any) <span class="cov0" title="0">{
        gameLogger.Warn(msg, addCallerInfo(attrs)...)
}</span>

// Error logs an error message
func Error(msg string, attrs ...any) <span class="cov0" title="0">{
        errorLogger.Error(msg, addCallerInfo(attrs)...)
}</span>

// Fatal logs a fatal error message and exits
func Fatal(msg string, attrs ...any) <span class="cov0" title="0">{
        errorLogger.Error(msg, addCallerInfo(attrs)...)
        os.Exit(1)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
